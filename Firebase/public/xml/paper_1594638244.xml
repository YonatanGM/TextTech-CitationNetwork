<paper id="1594638244"><title>Using C++ Templates to Implement Role-Based Designs</title><year>1996</year><authors><author org="University of Washington," id="1438645915">Michael VanHilst</author><author org="University of Washington," id="477007165">David Notkin</author></authors><n_citation>67</n_citation><doc_type /><references><reference>1484926667</reference><reference>1511610110</reference><reference>1595484050</reference><reference>1974552633</reference><reference>2023546887</reference><reference>2049966860</reference><reference>2052890401</reference><reference>2082340512</reference><reference>2086970510</reference><reference>2094282293</reference><reference>2115680394</reference><reference>2128419413</reference><reference>2139219581</reference><reference>2610715702</reference></references><venue id="" type="">ISOTAS '96 Proceedings of the Second JSSST International Symposium on Object Technologies for Advanced Software</venue><doi>10.1007/3-540-60954-7_41</doi><keywords><keyword weight="0.44813">Parameterized complexity</keyword><keyword weight="0.4675">Software engineering</keyword><keyword weight="0.56217">Compile time</keyword><keyword weight="0.46465">Computer science</keyword><keyword weight="0.56239">Reuse</keyword><keyword weight="0.47326">Implementation</keyword><keyword weight="0.57443">Code reuse</keyword><keyword weight="0.47586">Template</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Within the object-oriented technology community, much recent work on design reuse has focused on role-based collaborations distributed across multiple objects. Many benefits can be derived by mapping role-based designs directly into implementations, including greater ease in maintaining the connection between designs and implementations under change, and the opportunity for code reuse along with design reuse. Current efforts in role-based designs do not generally provide these benefits. We provide a method for mapping role-based designs into implementation, preserving the design without unnecessary constraints on the design structures. Roles are represented as parameterized classes, where the parameters represent the types of the participants in the collaboration. Composition of roles is implicit in the binding of parameters to classes in the implementation. The bindings are created at compile time by class definitions that are separate from the role implementations. In this paper we focus on the use of templates in the C++ language as the supporting mechanism.</abstract></paper>