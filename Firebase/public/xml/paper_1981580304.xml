<paper id="1981580304"><title>Two-level semantics and abstract interpretation</title><year>1989</year><authors><author org="Technical University of Denmark, Lyngby, Denmark." id="2057873166">F. Nielson</author></authors><n_citation>68</n_citation><doc_type>Journal</doc_type><references><reference>69359964</reference><reference>326743114</reference><reference>1491178396</reference><reference>1523016082</reference><reference>1544344167</reference><reference>1544564247</reference><reference>1562824671</reference><reference>1577579001</reference><reference>1591498447</reference><reference>1599561194</reference><reference>1753832216</reference><reference>1967177206</reference><reference>1980685577</reference><reference>1987031623</reference><reference>2014764321</reference><reference>2024873396</reference><reference>2025033165</reference><reference>2027657506</reference><reference>2037729105</reference><reference>2043100293</reference><reference>2048884568</reference><reference>2059019165</reference><reference>2062024564</reference><reference>2069293912</reference><reference>2071836561</reference><reference>2074756472</reference><reference>2093541252</reference><reference>2098780004</reference><reference>2115225924</reference><reference>2129419910</reference><reference>2130552670</reference><reference>2131733202</reference><reference>2141956765</reference><reference>2144517910</reference><reference>2169611723</reference><reference>2172307690</reference></references><venue id="90727058" type="J">Theoretical Computer Science</venue><doi>10.1016/0304-3975(89)90091-1</doi><keywords><keyword weight="0.65082">Operational semantics</keyword><keyword weight="0.46534">Programming language</keyword><keyword weight="0.59454">Abstract interpretation</keyword><keyword weight="0.4612">Computer science</keyword><keyword weight="0.51817">Partial evaluation</keyword><keyword weight="0.63198">Denotational semantics</keyword><keyword weight="0.60918">Correctness</keyword><keyword weight="0.54287">Data-flow analysis</keyword><keyword weight="0.46345">Theoretical computer science</keyword><keyword weight="0.58513">Program analysis</keyword><keyword weight="0.52227">Semantics</keyword></keywords><publisher>Elsevier Science Publishers Ltd.</publisher><abstract>Abstract Two-level semantics is a variant of Scott/Strachey denotational semantics in which the concept of binding time is treated explicitly. This is done by formally distinguishing between those computations that take place at run-time and those that take place at compile-time . Abstract interpretation is concerned with the (preferably automatic) analysis of programs. The main purpose of these analyses is to find information that may assist in the efficient implementation of the programs. Abstract interpretation is thus related to data flow analysis, partial evaluation and other program analysis methods. Its unique flavour is the insistence on formal proofs of correctness and the methods used to establish these. This paper develops a theory of abstract interpretation for two-level denotational definitions. There are three ingredients in this. First a framework for proving the correctness of analyses is developed. This may also be used to compare the precision of various analyses. Next it is shown that, given a choice of properties of programs, one may specify a most precise analysis (or best induced analysis). This may also be used to investigate the collecting semantics (or static semantics). Finally, we show how to modify the most precise analysis in order to obtain an implementable analysis where we trade off precision for implementability. The impact of this theoretical development is that for a large class of programming languages the semantic considerations of correctness and precision come for free by applications of metaresults: it merely suffices to define the analyses, the meaning of the properties studied and to prove the correctness of the language-dependent primitives. The theory then guarantees the correctness of the analyses for all programs. This success is one of the successes needed in order to develop efficient and provably correct implementations directly from semantic definitions.</abstract></paper>