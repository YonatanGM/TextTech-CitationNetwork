<paper id="1897405783"><title>Modular compilers based on monad transformers</title><year>1998</year><authors><author org="Dept. of Comput. Sci., Illinois, Univ., Urbana, IL, USA#TAB#" id="2168445747">W.L. Harrison</author><author org="" id="647470404">S.N. Kamin</author></authors><n_citation>24</n_citation><doc_type>Conference</doc_type><references><reference>1550946868</reference><reference>1987031623</reference><reference>1990347915</reference><reference>1997143185</reference><reference>2017383728</reference><reference>2037984920</reference><reference>2141576692</reference><reference>2159591963</reference></references><venue id="1140657324" type="C">International Conference on Computational Logistics</venue><doi>10.1109/ICCL.1998.674163</doi><keywords><keyword weight="0.47925">Programming language</keyword><keyword weight="0.54236">Programming language specification</keyword><keyword weight="0.51154">Expression (mathematics)</keyword><keyword weight="0.45431">Computer science</keyword><keyword weight="0.52739">Language construct</keyword><keyword weight="0.45439">Theoretical computer science</keyword><keyword weight="0.58607">Compiler</keyword><keyword weight="0.50823">Formal specification</keyword><keyword weight="0.52986">Interpreter</keyword><keyword weight="0.54147">Monad (functional programming)</keyword><keyword weight="0.49701">Semantics</keyword></keywords><publisher>IEEE Computer Society</publisher><abstract>The monadic style of language specification has the advantages of modularity and extensibility: it is simple to add or change features in an interpreter to reflect modifications in the source language. It has proven difficult to extend the method to compilation. We demonstrate that by introducing machine-like stores (code and data) into the monadic semantics and then partially evaluating the resulting semantic expressions, we can achieve many of the same advantages for a compiler as for an interpreter. A number of language constructs and features are compiled: expressions, CBV and CBN evaluation of /spl lambda/ expressions, dynamic scoping, and various imperative features. The treatment of recursive procedures is outlined as well. The resulting method allows compilers to be constructed in a mix and match fashion just as in a monad structured interpreter.</abstract></paper>