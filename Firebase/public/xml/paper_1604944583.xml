<paper id="1604944583"><title>Constraints for Polymorphic Behaviours of Concurrent ML</title><year>1994</year><authors><author org="Aarhus University," id="2057873166">Flemming Nielson</author><author org="Aarhus University," id="2345078223">Hanne Riis Nielson</author></authors><n_citation>8</n_citation><doc_type /><references><reference>1479857408</reference><reference>1525161337</reference><reference>1629236947</reference><reference>2017381819</reference><reference>2017720469</reference><reference>2051328776</reference><reference>2110135416</reference><reference>2118068787</reference><reference>2168658669</reference><reference>2914314632</reference></references><venue id="" type="">CCL '94 Proceedings of the First International Conference on Constraints in Computational Logics</venue><doi>10.1007/BFb0016845</doi><keywords><keyword weight="0.45672">Algebraic number</keyword><keyword weight="0.50099">Standard ML</keyword><keyword weight="0.45068">Algebra</keyword><keyword weight="0.52721">Concurrency</keyword><keyword weight="0.43102">Computer science</keyword><keyword weight="0.47904">Unification</keyword><keyword weight="0.41838">Parallel computing</keyword><keyword weight="0.54817">Concurrent ML</keyword><keyword weight="0.50046">Soundness</keyword><keyword weight="0.50212">Process calculus</keyword><keyword weight="0.52647">Free algebra</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We present a type and behaviour reconstruction algorithm for Standard ML with concurrency. The behaviours express the communication effects during execution and resemble terms of a process algebra. The algorithm uses unification for the (essentially) free algebra of types and algebraic reconstruction for collecting constraints for the non-free algebra of behaviours. The algorithm and the statement and proof of soundness are designed so as to make no assumptions on the existence of “principal” be-haviours as these are unlikely to exist. The main complication is that the notion of expansiveness does not suffice for a sufficiently general treatment of the polymorphic let-construct.</abstract></paper>