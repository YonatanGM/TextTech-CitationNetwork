<paper id="1530181486"><title>How to Protect Yourself without Perfect Shredding</title><year>2008</year><authors><author org="IBM T.J. Watson research center" id="687553606">Ran Canetti</author><author org="Google, Inc. (work done at Weizmann Institute of Science),#TAB#" id="2277956701">Dror Eiger</author><author org="MIT and Weizmann Institute of Science#TAB#" id="1728759264">Shafi Goldwasser</author><author org="mit" id="2274697921">Dah-Yoh Lim</author></authors><n_citation>11</n_citation><doc_type>Conference</doc_type><references><reference>175423693</reference><reference>236432643</reference><reference>1481692486</reference><reference>1498503799</reference><reference>1499934958</reference><reference>1505202270</reference><reference>1516739635</reference><reference>1520746637</reference><reference>1523616062</reference><reference>1530928880</reference><reference>1541483074</reference><reference>1576314536</reference><reference>1585065779</reference><reference>1587406858</reference><reference>1603601034</reference><reference>1801771305</reference><reference>1898653522</reference><reference>1967263393</reference><reference>1968372742</reference><reference>1970606468</reference><reference>1974411071</reference><reference>1983762057</reference><reference>1984459117</reference><reference>1994386233</reference><reference>2004315837</reference><reference>2007671490</reference><reference>2008718608</reference><reference>2015880590</reference><reference>2019616576</reference><reference>2022068408</reference><reference>2045717693</reference><reference>2052207834</reference><reference>2060474153</reference><reference>2074196013</reference><reference>2096024255</reference><reference>2104965768</reference><reference>2109394932</reference><reference>2116926584</reference><reference>2120164218</reference><reference>2138532540</reference><reference>2139279521</reference><reference>2141084119</reference><reference>2145765524</reference><reference>2165058514</reference><reference>2168970529</reference><reference>2169127491</reference><reference>2175377689</reference><reference>2250927570</reference><reference>2612259152</reference><reference>2913982177</reference></references><venue id="1141821850" type="C">International Colloquium on Automata, Languages and Programming</venue><doi>10.1007/978-3-540-70583-3_42</doi><keywords><keyword weight="0.40744">Psychological resilience</keyword><keyword weight="0.50464">Secure multi-party computation</keyword><keyword weight="0.0">Adaptive security</keyword><keyword weight="0.555">Cryptographic protocol</keyword><keyword weight="0.44736">Computer security</keyword><keyword weight="0.44442">Computer science</keyword><keyword weight="0.46434">Universal hashing</keyword><keyword weight="0.50968">Compiler</keyword><keyword weight="0.50056">Forward secrecy</keyword><keyword weight="0.43965">Erasure</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Erasing old data and keys is an important tool in cryptographic protocol design. It is useful in many settings, including proactive security, adaptive security, forward security, and intrusion resilience. Protocols for all these settings typically assume the ability to perfectly eraseinformation. Unfortunately, as amply demonstrated in the systems literature, perfect erasures are hard to implement in :[56],"propose a model of partial erasureswhere erasure instructions leave almost all the data erased intact, thus giving the honest players only a limited capability for disposing of old data. Nonetheless, we provide a general compiler that transforms any secure protocol using perfect erasures into one that maintains the same security properties when only partial erasures are available. The key idea is a new redundant representation of secret data which can still be computed on, and yet is rendered useless when partially erased. We prove that any such a compiler must incur a cost in additional storage, and that our compiler is near optimal in terms of its storage overhead.</abstract></paper>