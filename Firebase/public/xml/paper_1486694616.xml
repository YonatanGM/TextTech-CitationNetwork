<paper id="1486694616"><title>Types for Safe Locking</title><year>1999</year><authors><author org="Compaq" id="2130341195">Cormac Flanagan</author><author org="Compaq" id="2162106674">Mart√≠n Abadi</author></authors><n_citation>155</n_citation><doc_type>Conference</doc_type><references><reference>1479857408</reference><reference>1482207865</reference><reference>1531016348</reference><reference>1532319054</reference><reference>1571962375</reference><reference>1644882639</reference><reference>1972544179</reference><reference>1986053257</reference><reference>2017381819</reference><reference>2036601332</reference><reference>2039549168</reference><reference>2046137117</reference><reference>2064264121</reference><reference>2065675749</reference><reference>2066952803</reference><reference>2087875803</reference><reference>2105180288</reference><reference>2107978495</reference><reference>2112751084</reference><reference>2132500556</reference><reference>2148901852</reference><reference>2294680933</reference><reference>2295450001</reference></references><venue id="1136861413" type="C">European Symposium on Programming</venue><doi>10.1007/3-540-49099-X_7</doi><keywords><keyword weight="0.54992">Race condition</keyword><keyword weight="0.49964">Data structure</keyword><keyword weight="0.42931">Programming language</keyword><keyword weight="0.50165">Functional programming</keyword><keyword weight="0.43543">Computer science</keyword><keyword weight="0.50252">Lock (computer science)</keyword><keyword weight="0.48502">Deadlock</keyword><keyword weight="0.52466">Critical section</keyword><keyword weight="0.51265">Imperative programming</keyword><keyword weight="0.42621">Theoretical computer science</keyword><keyword weight="0.50377">Thread (computing)</keyword><keyword weight="0.42275">Distributed computing</keyword></keywords><publisher>Springer-Verlag</publisher><abstract>A race condition is a situation where two threads manipulate a data structure simultaneously, without synchronization. Race conditions are common errors in multithreaded programming. They often lead to unintended nondeterminism and wrong results. Moreover, they are notoriously hard to diagnose, and attempts to eliminate them can introduce deadlocks. In practice, race conditions and deadlocks are often avoided through prudent programming discipline: protecting each shared data structure with a lock and imposing a partial order on lock acquisitions. In this paper we show that this discipline can be captured (if not completely, to a significant extent) through a set of static rules. We present these rules as a type system for a concurrent, imperative language. Although weaker than a full-blown program-verification calculus, the type system is effective and easy to apply. We emphasize a core, first-order type system focused on race conditions; we also consider extensions with polymorphism, existential types, and a partial order on lock types.</abstract></paper>