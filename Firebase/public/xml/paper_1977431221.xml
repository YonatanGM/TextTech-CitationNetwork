<paper id="1977431221"><title>Open implementation design guidelines</title><year>1997</year><authors><author org="Xerox Palo Alto Research Center, 3333 Coyote Hill Road, Palo Alto, CA" id="562619066">Gregor Kiczales</author><author org="Xerox Palo Alto Research Center, 3333 Coyote Hill Road, Palo Alto, CA" id="1763576553">John Lamping</author><author org="Xerox Palo Alto Research Center, 3333 Coyote Hill Road, Palo Alto, CA" id="2974591905">Christina Videira Lopes</author><author org="Xerox Palo Alto Research Center, 3333 Coyote Hill Road, Palo Alto, CA" id="2974781439">Chris Maeda</author><author org="Xerox Palo Alto Research Center, 3333 Coyote Hill Road, Palo Alto, CA" id="2577906926">Anurag Mendhekar</author><author org="Department of Computer Science, University of British Columbia, 201-2366 Main Mall, Vancouver B.C., Canada V6T 1Z4" id="2100357700">Gail Murphy</author></authors><n_citation>108</n_citation><doc_type>Conference</doc_type><references><reference>1806657109</reference><reference>1966938284</reference><reference>1978220811</reference><reference>1988827547</reference><reference>2008633193</reference><reference>2013543248</reference><reference>2038469228</reference><reference>2052599259</reference><reference>2076638640</reference><reference>2077097918</reference><reference>2084776520</reference><reference>2090279384</reference><reference>2108033349</reference><reference>2111804808</reference><reference>2134119432</reference></references><venue id="1174403976" type="C">International Conference on Software Engineering</venue><doi>10.1145/253228.253431</doi><keywords><keyword weight="0.65403">Open implementation</keyword><keyword weight="0.54371">Software design</keyword><keyword weight="0.46292">Systems engineering</keyword><keyword weight="0.47142">Software engineering</keyword><keyword weight="0.46288">Computer science</keyword><keyword weight="0.51395">Package development process</keyword><keyword weight="0.52941">Component-based software engineering</keyword><keyword weight="0.5323">Resource-oriented architecture</keyword><keyword weight="0.53125">Software construction</keyword><keyword weight="0.53451">Software development</keyword><keyword weight="0.53553">Software requirements</keyword></keywords><publisher>ACM</publisher><abstract>Designing reusable software modules can be extremely difficult. The design must be balanced between being general enough to address the needs of a wide range of clients and being focused enough to truly satisfy the requirements of each specific client. One area where it can be particularly difficult to strike this balance is in the implementation strategy of the module. The problem is that general-purpose implementation strategies, tuned for a wide range of clients, aren’t necessarily optimal for each specific client— this is especially an issue for modules that are intended to be reusable and yet provide highperformance. An examination of existing software systems shows that an increasingly important technique for handling this problem is to design the module’s interface in such a way that the client can assist or participate in the selection of the module’s implementation strategy. We call this approach open implementation. When designing the interface to a module that allows its clients some control over its implementation strategy, it is important to retain, as much as possible, the advantages of traditional closed implementation modules. This paper explores issues in the design of interfaces to open implementation modules. We identify key design choices, and present guidelines for deciding which choices are likely to work best in particular situations.</abstract></paper>