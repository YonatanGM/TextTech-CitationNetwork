<paper id="1985161650"><title>Branching time and abstraction in bisimulation semantics</title><year>1996</year><authors><author org="Computer Science Department, Stanford University, CA and Centrun voor Wiskunde en Informatica, Amsterdam, The Netherlands#TAB#" id="2168271037">Rob J. van Glabbeek</author><author org="PTT Telecom, Postbus 30150, 2500 GD's Gravenhage, The Netherlands and Centrun roor Wiskunde en Informatica, Amsterdam, The Netherlands" id="2683725935">W. Peter Weijland</author></authors><n_citation>616</n_citation><doc_type>Journal</doc_type><references><reference>80787065</reference><reference>140793526</reference><reference>1487199072</reference><reference>1501731334</reference><reference>1503973138</reference><reference>1543050278</reference><reference>1547562281</reference><reference>1560779502</reference><reference>1571377821</reference><reference>1577673148</reference><reference>1586966546</reference><reference>1589421353</reference><reference>1602925513</reference><reference>1608445965</reference><reference>1861107327</reference><reference>1883772204</reference><reference>1965551437</reference><reference>1966112122</reference><reference>1972478730</reference><reference>1978469611</reference><reference>1990183105</reference><reference>1990440312</reference><reference>1997387389</reference><reference>2000630835</reference><reference>2001748564</reference><reference>2003477691</reference><reference>2004306067</reference><reference>2021473546</reference><reference>2036267700</reference><reference>2041561080</reference><reference>2043801088</reference><reference>2057403696</reference><reference>2098981343</reference><reference>2102097307</reference><reference>2106934908</reference><reference>2107144615</reference><reference>2107733072</reference><reference>2108796478</reference><reference>2110425399</reference><reference>2118044617</reference><reference>2129965117</reference><reference>2130994701</reference><reference>2133409888</reference><reference>2134038996</reference><reference>2140269481</reference><reference>2144545266</reference><reference>2150320481</reference><reference>2158942489</reference><reference>2160548641</reference><reference>2163123880</reference><reference>2166216406</reference><reference>2167004912</reference><reference>2591141241</reference><reference>2913461254</reference></references><venue id="118992489" type="J">Journal of the ACM</venue><doi>10.1145/233551.233556</doi><keywords><keyword weight="0.441">Discrete mathematics</keyword><keyword weight="0.57493">Logical equivalence</keyword><keyword weight="0.43726">Combinatorics</keyword><keyword weight="0.44575">Formal language</keyword><keyword weight="0.45809">Concurrency</keyword><keyword weight="0.48978">Concurrency semantics</keyword><keyword weight="0.57515">Equivalence (measure theory)</keyword><keyword weight="0.58824">Bisimulation</keyword><keyword weight="0.454">Time complexity</keyword><keyword weight="0.49785">Congruence (geometry)</keyword><keyword weight="0.40678">Mathematics</keyword></keywords><publisher>ACM</publisher><abstract>In comparative concurrency semantics, one usually distinguishes between linear time and branching time semantic equivalences. Milneru0027s notion of observatin equivalence is often mentioned as the standard example of a branching time equivalence. In this paper we investigate whether observation equivalence really does respect the branching structure of processes, and find that in the presence of the unobservable action τ of CCS this is not the case. Therefore, the notion of branching bisimulation equivalence is introduced which strongly preserves the branching structure of processes, in the sense that it preserves computations together with the potentials in all intermediate states that are passed through, even if silent moves are involved. On closed CCS-terms branching bisimulation congruence can be completely axiomatized by the single axion scheme: a.(τ.(y+z)+y)=a.(y+z) (where a ranges over all actions) and the usual loaws for strong congruence. We also establish that for sequential processes observation equivalence is not preserved under refinement of actions, whereas branching bisimulation is. For a large class of processes, it turns out that branching bisimulation and observation equivalence are the same. As far as we know, all protocols that have been verified in the setting of observation equivalence happen to fit in this class, and hence are also valid in the stronger setting of branching bisimulation equivalence.</abstract></paper>