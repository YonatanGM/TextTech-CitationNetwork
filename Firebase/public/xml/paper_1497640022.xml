<paper id="1497640022"><title>Reversible communicating systems</title><year>2004</year><authors><author org="UniversitÃ© Paris 7 &amp; CNRS" id="2182243253">Vincent Danos</author><author org="INRIA Rocquencourt#TAB#" id="2023873246">Jean Krivine</author></authors><n_citation>303</n_citation><doc_type>Conference</doc_type><references><reference>1503973138</reference><reference>1508393535</reference><reference>1532326694</reference><reference>1540173432</reference><reference>1561232828</reference><reference>1578801263</reference><reference>1793309813</reference><reference>2007006124</reference><reference>2020813639</reference><reference>2025170645</reference><reference>2048909687</reference><reference>2070503710</reference><reference>2084118108</reference><reference>2095417604</reference><reference>2110796675</reference><reference>2912201013</reference><reference>2913408576</reference></references><venue id="1145706541" type="C">International Conference on Concurrency Theory</venue><doi>10.1007/978-3-540-28644-8_19</doi><keywords><keyword weight="0.46825">Synchronization</keyword><keyword weight="0.46834">Computer science</keyword><keyword weight="0.55466">Concurrency</keyword><keyword weight="0.4751">Theoretical computer science</keyword><keyword weight="0.48601">If and only if</keyword><keyword weight="0.53486">Process calculus</keyword><keyword weight="0.52292">Computation</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>One obtains in this paper a process algebra RCCS, in the style of CCS, where processes can backtrack. Backtrack, just as plain forward computation, is seen as a synchronization and incurs no additional cost on the communication structure. It is shown that, given a past, a computation step can be taken back if and only if it leads to a causally equivalent past.</abstract></paper>