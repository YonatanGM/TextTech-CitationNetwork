<paper id="1486579717"><title>Processing Unions of Conjunctive Queries with Negation under Limited Access Patterns</title><year>2004</year><authors><author org="Department of Mathematics" id="2135569827">Alan Nash</author><author org="University of California" id="2239188769">Bertram Ludäscher</author></authors><n_citation>28</n_citation><doc_type>Conference</doc_type><references><reference>1480742455</reference><reference>1489525677</reference><reference>1505230898</reference><reference>1515943552</reference><reference>1910521678</reference><reference>1979514837</reference><reference>1991640369</reference><reference>2010308380</reference><reference>2013112375</reference><reference>2056660085</reference><reference>2080464727</reference><reference>2084761702</reference><reference>2134483537</reference></references><venue id="1132593990" type="C">Extending Database Technology</venue><doi>10.1007/978-3-540-24741-8_25</doi><keywords><keyword weight="0.4384">Data mining</keyword><keyword weight="0.64578">Conjunctive query</keyword><keyword weight="0.0">Database query</keyword><keyword weight="0.46224">Negation</keyword><keyword weight="0.44839">Computer science</keyword><keyword weight="0.47542">Completeness (statistics)</keyword><keyword weight="0.4349">Database</keyword><keyword weight="0.52243">Executable</keyword><keyword weight="0.64024">Query plan</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We study the problem of answering queries over sources with limited access patterns. The problem is to decide whether a given query Q is feasible, i.e., equivalent to an executable query Q′ that observes the limited access patterns given by the sources. We characterize the complexity of deciding feasibility for the classes CQ¬ (conjunctive queries with negation) and UCQ¬ (unions of CQ¬ queries): Testing feasibility is just as hard as testing containment and therefore \(\Pi^{P}_{2}\)-complete. We also provide a uniform treatment for CQ, UCQ, CQ¬, and UCQ¬ by devising a single algorithm which is optimal for each of these classes. In addition, we show how one can often avoid the worst-case complexity by certain approximations: At compile-time, even if a query Q is not feasible, we can find efficiently the minimal executable query containing Q. For query answering at runtime, we devise an algorithm which may report complete answers even in the case of infeasible plans and which can indicate to the user the degree of completeness for certain incomplete answers.</abstract></paper>