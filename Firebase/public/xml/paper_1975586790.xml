<paper id="1975586790"><title>A proof technique for communicating sequential processes</title><year>1981</year><authors><author org="Department of Computer Science, University of Arizona, Tucson, USA#TAB#" id="2170020184">Gary Marc Levin</author><author org="Department of Computer Science, Cornell University, Ithaca, USA#TAB#" id="1980295760">David Gries</author></authors><n_citation>131</n_citation><doc_type>Journal</doc_type><references><reference>1505745216</reference><reference>1964727056</reference><reference>1980529102</reference><reference>1984831616</reference><reference>2038952689</reference><reference>2081733938</reference><reference>2084291524</reference><reference>2103953153</reference><reference>2110425399</reference><reference>2111706174</reference><reference>2296352387</reference></references><venue id="84409463" type="J">Acta Informatica</venue><doi>10.1007/BF00289266</doi><keywords><keyword weight="0.48497">Information theory</keyword><keyword weight="0.48495">Information system</keyword><keyword weight="0.48806">Data structure</keyword><keyword weight="0.42479">Discrete mathematics</keyword><keyword weight="0.45368">Telecommunications network</keyword><keyword weight="0.46998">Computer science</keyword><keyword weight="0.58097">Communicating sequential processes</keyword><keyword weight="0.61998">Correctness</keyword><keyword weight="0.58126">Deadlock</keyword></keywords><publisher>Springer-Verlag New York, Inc.</publisher><abstract>Proof rules are presented for an extension of Hoareu0027s Communicating Sequential Processes. The rules deal with total correctness; all programs terminate in the absence of deadlock. The commands send and receive are treated symmetrically, simplifying the rules and allowing send to appear in guards. Also given are sufficient conditions for showing that a program is deadlock-free. An extended example illustrates the use of the technique.</abstract></paper>