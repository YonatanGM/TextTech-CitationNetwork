<paper id="1500983737"><title>Checking properties of heap-manipulating procedures with a constraint solver</title><year>2003</year><authors><author org="Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Massachusetts," id="2137037304">Mandana Vaziri</author><author org="Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Massachusetts," id="2120858950">Daniel Jackson</author></authors><n_citation>41</n_citation><doc_type>Conference</doc_type><references><reference>1576135198</reference><reference>1975914482</reference><reference>1991837261</reference><reference>1999997889</reference><reference>2026965951</reference><reference>2074845051</reference><reference>2075959177</reference><reference>2082000355</reference><reference>2107995193</reference><reference>2115309705</reference><reference>2135274583</reference><reference>2164392635</reference><reference>2169102536</reference><reference>2171480813</reference></references><venue id="1159071770" type="C">Tools and Algorithms for Construction and Analysis of Systems</venue><doi>10.1007/3-540-36577-X_37</doi><keywords><keyword weight="0.42689">Discrete mathematics</keyword><keyword weight="0.466">Programming language</keyword><keyword weight="0.45584">Computer science</keyword><keyword weight="0.55616">Boolean satisfiability problem</keyword><keyword weight="0.46322">Theoretical computer science</keyword><keyword weight="0.59675">Heap (data structure)</keyword><keyword weight="0.56846">Conjunctive normal form</keyword><keyword weight="0.50882">Counterexample</keyword><keyword weight="0.54685">True quantified Boolean formula</keyword><keyword weight="0.50495">Boolean data type</keyword><keyword weight="0.55046">Propositional formula</keyword><keyword weight="0.52528">Propositional variable</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>A method for finding bugs in object-oriented code is presented. It is capable of checking complex user-defined structural properties - that is, of the configuration of objects on the heap - and generates counterexample traces with no false alarms. It requires no annotation beyond the specification to be checked, and is fully method :[52],"relies on a three-step translation: from code to a formula in a first-order relational logic, then to a propositional formula, and finally to conjunctive normal form. An off-the-shelf SAT solver is then used to find a solution that constitutes a counter :[95],"underlying scheme, presented previously, does not scale readily. In this paper, we show how a suite of optimizations results in much improved scalability. The optimizations are based on a special treatment of relations that are known to be functional, and target all steps. The effect of the optimizations is demonstrated by application to the analysis of a red-black tree implementation.</abstract></paper>