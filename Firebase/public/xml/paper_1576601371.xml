<paper id="1576601371"><title>Experiments with ROO: A Parallel Automated Deduction System</title><year>1990</year><authors><author org="Argonne National Laboratory,#TAB#" id="1977610862">Ewing L. Lusk</author><author org="Argonne National Laboratory,#TAB#" id="2113235922">William McCune</author></authors><n_citation>30</n_citation><doc_type /><references><reference>1554786964</reference><reference>1587968455</reference><reference>1832368449</reference><reference>1841535323</reference><reference>1869961429</reference><reference>1972956465</reference><reference>1985789487</reference><reference>1999990752</reference><reference>2022796917</reference><reference>2044493912</reference><reference>2085193930</reference></references><venue id="" type="">Proceedings of the International Workshop on Parallelization in Inference Systems</venue><doi>10.1007/3-540-55425-4_6</doi><keywords><keyword weight="0.0">Theorem provers</keyword><keyword weight="0.0">General purpose</keyword><keyword weight="0.44642">Computer science</keyword><keyword weight="0.53081">Parallel algorithm</keyword><keyword weight="0.48949">Automated theorem proving</keyword><keyword weight="0.46406">Closure (topology)</keyword><keyword weight="0.4523">Theoretical computer science</keyword><keyword weight="0.47866">Completeness (statistics)</keyword><keyword weight="0.46298">Computation</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>The automated theorem prover OTTER[12 , 14] represents the state of the art in high-speed, general purpose theorem provers. One way to increase OTTERu0027S speed further is through the exploitation of parallelism. A general, parallel algorithm for the computing the closure of a set under an operation was presented in [18]. Since OTTEt{u0027s fundamental algorithm can be viewed as a closure computation, this algorithm can be applied to OTTER. The result is Roo, a parallel theorem prover compatible with OTTER that runs on shared-memory multiprocessors. Roo itself is described in [8] and [9]. For completeness we present a summary of the basic algorithm in Section 2. Compared with the numerical applications typically run on todayu0027s multiprocessors, Roou0027s behavior is considerably more complex. Its algorithm performs well in general, but in certain situations does badly. Some of these situations reflect only certain phases of runs on particular problems. Sometimes 1~oo, even with only one process, outperforms OTTER, and sometimes it does much worse. Speedups are often roughly linear, which is why we are well-satisfied with P~oo. Sometimes they are far below linear, and sometimes startlingly superlinear. In general, a full appreciation of the subtleties of parallel computation in this application area can only be obtained by looking closely at the behavior of Roo on a wide variety of theorem-proving problems. The purpose of this paper is to provide such a detailed look. After summarizing the algorithms of OTTER and Roo in Section 2, we present a series of experiments taken from a wide variety of test problems. These show Roo both at its best and its worst and exhibit a number of surprising features. Since the problems themselves are of interest, we provide (except in one rather tedious case) the complete set of input clauses that make up the problem. For each problem we exhibit the performance of Roo and analyze the results. Finally, the non-deterministic nature of parallel algorithms means that consecutive runs of the same input file, on the same number of processes, can produce different results. In Section 4 we address the question of the stability and reproducibility of the results we have reported for Roo.</abstract></paper>