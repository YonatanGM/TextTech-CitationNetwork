<paper id="1482715091"><title>Efficient representation and validation of proofs</title><year>1998</year><authors><author org="School of Computer Science Carnegie Mellon University, Pittsburgh, PA, USA" id="281330718">G.C. Necula</author><author org="" id="2974708134">P. Lee</author></authors><n_citation>98</n_citation><doc_type>Conference</doc_type><references><reference>1974190112</reference><reference>2025407135</reference><reference>2075352622</reference><reference>2084443499</reference><reference>2107923385</reference><reference>2150769115</reference><reference>2295866357</reference></references><venue id="1171002971" type="C">Logic in Computer Science</venue><doi>10.1109/LICS.1998.705646</doi><keywords><keyword weight="0.42445">ENCODE</keyword><keyword weight="0.43838">Discrete mathematics</keyword><keyword weight="0.4492">Computer science</keyword><keyword weight="0.42066">Megabyte</keyword><keyword weight="0.50315">Automated theorem proving</keyword><keyword weight="0.46032">Theoretical computer science</keyword><keyword weight="0.47228">Redundancy (engineering)</keyword><keyword weight="0.54302">Mathematical proof</keyword><keyword weight="0.57914">Proof complexity</keyword><keyword weight="0.54106">Logical framework</keyword><keyword weight="0.61007">Proof assistant</keyword></keywords><publisher>IEEE Computer Society</publisher><abstract>This paper presents a logical framework derived from the Edinburgh Logical Framework (LF) that can be used to obtain compact representations of proofs and efficient proof checkers. These are essential ingredients of any application that manipulates proofs as first-class objects, such as a Proof-Carrying Code system, in which proofs are used to support easy validation of properties of safety-critical or untrusted code. Our framework, which we call LF/sub i/, inherits from LF the capability to encode various logics in a natural way. In addition, the LF/sub i/ framework allows proof representations without the high degree of redundancy that is characteristic of LF representations. The missing parts of LF/sub i/ proof representations can be reconstructed during proof checking by an efficient reconstruction algorithm. We also describe an algorithm that can be used to strip the unnecessary parts of an LF representation of a proof. The experimental data that we gathered in the context of a Proof-Carrying Code system shows that the savings obtained from using LF/sub i/ instead of LF can make the difference between practically useless proofs of several megabytes and manageable proofs of tens of kilobytes.</abstract></paper>