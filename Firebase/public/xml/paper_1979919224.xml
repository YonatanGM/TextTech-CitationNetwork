<paper id="1979919224"><title>Extending Multiversion Time-Stamping Protocols to Exploit Type Information</title><year>1987</year><authors><author org="Department of Computer Science|Carnegie Mellon University" id="1561680098">Herlihy</author></authors><n_citation>26</n_citation><doc_type>Journal</doc_type><references><reference>1973501242</reference><reference>1991199257</reference><reference>1992044086</reference><reference>2012848290</reference><reference>2023304911</reference><reference>2075570590</reference><reference>2076627572</reference><reference>2093162068</reference><reference>2106887953</reference><reference>2141078283</reference><reference>2142849519</reference><reference>2153579478</reference><reference>2154566471</reference><reference>2389944897</reference></references><venue id="157670870" type="J">IEEE Transactions on Computers</venue><doi>10.1109/TC.1987.1676926</doi><keywords><keyword weight="0.55935">Atomicity</keyword><keyword weight="0.52872">Serializability</keyword><keyword weight="0.45924">Computer science</keyword><keyword weight="0.45736">Computer network</keyword><keyword weight="0.44976">Real-time computing</keyword><keyword weight="0.46719">Distributed computing</keyword><keyword weight="0.49745">Abstract data type</keyword><keyword weight="0.51892">Concurrency control</keyword><keyword weight="0.45567">Parallel computing</keyword><keyword weight="0.46362">Automaton</keyword><keyword weight="0.44775">Queue</keyword><keyword weight="0.4637">Exploit</keyword><keyword weight="0.46896">Fault tolerance</keyword></keywords><publisher>IEEE</publisher><abstract>Atomic transactions are a widely accepted approach to implementing and reasoning about fault-tolerant distributed programs. This paper shows how multiversion time-stamping protocols for atomicity can be extended to induce fewer delays and restarts by exploiting semantic information about objects such as queues, directories, or counters. This technique relies on static preanalysis of conflicts between operations, and incurs no additioiwal runtime overhead. This technique is deadlock-free, and it is applicable to objects of arbitrary type.</abstract></paper>