<paper id="1562611359"><title>Polymorphic Subtype Inference: Closing the Theory-Practice Gap</title><year>1989</year><authors><author org="The State University of New York at Stony Brook" id="2645040543">You-Chin Fuh</author><author org="The State University of New York at Stony Brook" id="2171597218">Prateek Mishra</author></authors><n_citation>55</n_citation><doc_type /><references><reference>1703087989</reference><reference>1969093922</reference><reference>2166822586</reference></references><venue id="" type="">TAPSOFT '89 Proceedings of the International Joint Conference on Theory and Practice of Software Development, Volume 2: Advanced Seminar on Foundations of Innovative Software Development II and Colloquium on Current Issues in Programming Languages</venue><doi>10.1007/3-540-50940-2_35</doi><keywords><keyword weight="0.0">Correctness proofs</keyword><keyword weight="0.43487">Computer science</keyword><keyword weight="0.5575">Inference</keyword><keyword weight="0.53094">Correctness</keyword><keyword weight="0.55173">Preorder</keyword><keyword weight="0.54445">Type inference</keyword><keyword weight="0.45347">Theoretical computer science</keyword><keyword weight="0.51966">Equivalence (measure theory)</keyword><keyword weight="0.5212">Equivalence class</keyword><keyword weight="0.52782">Instance relation</keyword><keyword weight="0.291">Genetics</keyword></keywords><publisher>Springer-Verlag</publisher><abstract>The theory of polymorphic type inference[Mi178] has been extended to deal with subtypes: Mitchell gave a subtype extension [Mit84], and we have given algorithms and correctness proofs for several key components of a type inference system based on Mitchellu0027s extension [FM88]. However, the actual implementation of a subtype inference system diverges from these theoreticM underpinnings in fundamentally important ways. By examining this divergence, we close the gap between the theoretical foundations of subtype inference and its actual use. We give two results: first, we observe that Mitchellu0027s instance relation is exactly a preorder and hence principal types are unique only up to equivalence. We show the existence of a unique minimal representative for each equivalence class of typings and give an algorithm for computing such representatives. In practice, we find it unnecessary to transform typings into their exact minimal forms. Instead, it is sufficient to remove certain redundancies from typings; this transforms most typings into their exact minimal form. We describe an efficient algorithm that implements this transformation and prove its correctness. Second, we propose a new "lazy" instance definition s that defers coercions wherever possible. The advantage of the lazy instance definition over Mitchellu0027s is that its use leads to an extremely compact representation for the unique minimal form of a typing. Following the framework described above, we describe a transformation, based on the lazy instance definition, that eliminates certain redundancies from typings. For many programs, removing redundancies from typings under the lazy instance definition leads to a coercion set of size at most one.</abstract></paper>