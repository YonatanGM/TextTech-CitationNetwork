<paper id="1965336482"><title>Real-time garbage collection on general-purpose machines</title><year>1990</year><authors><author org="Research Institute for Mathematical Sciences; Kyoto University; Kyoto Japan" id="2974162058">T. Yuasa</author></authors><n_citation>139</n_citation><doc_type>Journal</doc_type><references><reference>1983156473</reference><reference>1987079491</reference><reference>2026416960</reference><reference>2045255985</reference><reference>2079813853</reference><reference>2112630372</reference><reference>2127007340</reference><reference>2130376240</reference><reference>2156956446</reference><reference>2158525816</reference><reference>2161531345</reference><reference>2611598995</reference></references><venue id="37879656" type="J">Journal of Systems and Software</venue><doi>10.1016/0164-1212(90)90084-Y</doi><keywords><keyword weight="0.5451">Pointer (computer programming)</keyword><keyword weight="0.54624">Garbage</keyword><keyword weight="0.63259">Mark-compact algorithm</keyword><keyword weight="0.45262">Computer science</keyword><keyword weight="0.65726">Manual memory management</keyword><keyword weight="0.45643">Parallel computing</keyword><keyword weight="0.54052">Lisp</keyword><keyword weight="0.59132">Data pre-processing</keyword><keyword weight="0.69869">Garbage collection</keyword><keyword weight="0.64078">Garbage in, garbage out</keyword><keyword weight="0.45324">Operating system</keyword></keywords><publisher>Elsevier Science Inc.</publisher><abstract>Abstract An algorithm for real-time garbage collection is presented, proved correct, and evaluated. This algorithm is intended for list-processing systems on general-purpose machines, i.e., Von Neumann style serial computers with a single processor. On these machines, real-time garbage collection inevitably causes some overhead on the overall execution of the list-processing system, because some of the primitive list-processing operations must check the status of garbage collection. By removing such overhead from frequently used primitives such as pointer references (e.g., Lisp car and cdr) and stack manipulations, the presented algorithm reduces the execution overhead to a great extent. Although the algorithm does not support compaction of the whole data space, it efficiently supports partial compaction such as array relocation.</abstract></paper>