<paper id="1592879001"><title>Conditional Graph Rewriting as a Domain-Independent Formalism for Software Evolution</title><year>1999</year><authors><author org="Vrije Universiteit Brussel" id="1986880241">Tom Mens</author></authors><n_citation>40</n_citation><doc_type /><references><reference>1503948619</reference><reference>1523742478</reference><reference>1560962701</reference><reference>1587555185</reference><reference>1600993531</reference><reference>1942703822</reference><reference>1986466161</reference><reference>1992050254</reference><reference>2001907377</reference><reference>2032566068</reference><reference>2068536883</reference><reference>2075017593</reference><reference>2094944943</reference><reference>2096937604</reference><reference>2127455123</reference><reference>2151803774</reference><reference>2165681774</reference><reference>2215315499</reference><reference>2915014422</reference></references><venue id="" type="">AGTIVE '99 Proceedings of the International Workshop on Applications of Graph Transformations with Industrial Relevance</venue><doi>10.1007/3-540-45104-8_10</doi><keywords><keyword weight="0.61756">Software design</keyword><keyword weight="0.47247">Programming language</keyword><keyword weight="0.46163">Computer science</keyword><keyword weight="0.47107">Theoretical computer science</keyword><keyword weight="0.64788">Graph rewriting</keyword><keyword weight="0.62836">Component-based software engineering</keyword><keyword weight="0.62823">Software visualization</keyword><keyword weight="0.65206">Software evolution</keyword><keyword weight="0.63645">Goal-Driven Software Development Process</keyword><keyword weight="0.62352">Software framework</keyword><keyword weight="0.62602">Software development</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>This paper presents a formal approach for managing unanticipated software evolution. Labelled typed nested graphs are used to represent arbitrarily complex software artifacts, and conditional graph rewriting is used for managing evolution of these artifacts. More specifically, we detect structural and behavioural inconsistencies when merging parallel evolutions of the same software artifact. The approach is domain-independent, in the sense that it can be customised to many different domains, such as software architectures, UML analysis and design models, and software code.</abstract></paper>