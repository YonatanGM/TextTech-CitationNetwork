<paper id="1525928754"><title>Bounded-memory Algorithms for Verification On-the-fly</title><year>1991</year><authors><author org="IRISA, Campus de Beaulieu" id="182723510">Claude Jard</author><author org="IRISA, Campus de Beaulieu" id="1998327350">Thierry JÃ©ron</author></authors><n_citation>54</n_citation><doc_type>Conference</doc_type><references><reference>1505315292</reference><reference>1517157359</reference><reference>1569068921</reference><reference>1934074768</reference><reference>2001426769</reference><reference>2012935476</reference><reference>2029117638</reference><reference>2042087007</reference><reference>2067782667</reference><reference>2128843729</reference><reference>2129335898</reference><reference>2147539576</reference><reference>2554105671</reference></references><venue id="1162450063" type="C">Computer Aided Verification</venue><doi>10.1007/3-540-55179-4_19</doi><keywords><keyword weight="0.4764">Computer science</keyword><keyword weight="0.61443">Correctness</keyword><keyword weight="0.44275">Algorithm</keyword><keyword weight="0.57835">Formal specification</keyword><keyword weight="0.46486">Theoretical computer science</keyword><keyword weight="0.50222">Linear temporal logic</keyword><keyword weight="0.51764">Finite-state machine</keyword><keyword weight="0.51118">Mathematical proof</keyword><keyword weight="0.5728">Symbolic execution</keyword><keyword weight="0.53501">State space</keyword><keyword weight="0.53546">Formal proof</keyword></keywords><publisher>Springer-Verlag</publisher><abstract>Program verification is a branch of computer science whose business is "to prove programs correctness". It has been studied in theoretical computer science departments for a long time but it is rarely and laboriously applied to real world problems. As a matter of fact, we must pay much more attention to practical problems like the amount of space and time needed to perform verification. Let us recall that proofs of correctness are proofs of the relative consistency between two formal specifications: those of the program, and of the properties that the program is supposed to satisfy. Such a formal proof tries to increase the confidence that a computer system will make it right when executing the program under consideration. A considerable need for such methods appeared these last ten years in different domains, such as design of asynchronous circuits, communication protocols and distributed software in general. A lot of us accepted the challenge to design automated verification tools, and many different theories have been suggested for the automated analysis of distributed systems. There now exist elaborate methods that can verify quite subtle behaviors. A simple method for performing automated verification is symbolic execution which is the core of most existing and planned verification systems. The practical limits of this method are the size of the state space and the time it may take to inspect all reachable states in this state space. Those quantities can dramatically rise with the problem size.</abstract></paper>