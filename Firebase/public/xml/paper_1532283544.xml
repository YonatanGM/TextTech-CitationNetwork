<paper id="1532283544"><title>Refactoring UML Models</title><year>2001</year><authors><author org="IRISA, Campus de Beaulieu" id="2657923944">Gerson Sunyé</author><author org="IRISA, Campus de Beaulieu" id="2102846446">Damien Pollet</author><author org="IRISA, Campus de Beaulieu" id="494248588">Yves Le Traon</author><author org="IRISA, Campus de Beaulieu" id="2807702182">Jean-Marc Jézéquel</author></authors><n_citation>213</n_citation><doc_type>Journal</doc_type><references><reference>1566214218</reference><reference>2013060213</reference><reference>2145358680</reference><reference>2169644264</reference><reference>2172168118</reference></references><venue id="106296714" type="J">Lecture Notes in Computer Science</venue><doi>10.1007/3-540-45441-1_11</doi><keywords><keyword weight="0.53097">Program transformation</keyword><keyword weight="0.47723">Programming language</keyword><keyword weight="0.55548">Unified Modeling Language</keyword><keyword weight="0.53287">Object-oriented programming</keyword><keyword weight="0.47157">Computer science</keyword><keyword weight="0.53368">State diagram</keyword><keyword weight="0.49706">Software</keyword><keyword weight="0.45556">Artificial intelligence</keyword><keyword weight="0.59316">Object Constraint Language</keyword><keyword weight="0.62057">Code refactoring</keyword><keyword weight="0.61125">Class diagram</keyword><keyword weight="0.46239">Distributed computing</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Software developers spend most of their time modifying and maintaining existing products. This is because systems, and consequently their design, are in perpetual evolution before they die. Nevertheless, dealing with this evolution is a complex task. Before evolving a system, structural modifications are often required. The goal of this kind of modification is to make certain elements more extensible, permitting the addition of new features. However, designers are seldom able to evaluate the impact, on the whole model, of a single modification. That is, they cannot precisely verify if a change modifies the behavior of the modeled system. A possible solution for this problem is to provide designers with a set of basic transformations, which can ensure behavior preservation. These transformations, also known as refactorings, can then be used, step by step, to improve the design of the system. In this paper we present a set of refactorings and explain how they can be designed so as to preserve the behavior of a UML model. Some of these refactorings are illustrated with examples.</abstract></paper>