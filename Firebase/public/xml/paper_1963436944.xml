<paper id="1963436944"><title>Proving Noninterference and Functional Correctness Using Traces</title><year>1992</year><authors><author org="Center for Secure Information Technology, Naval Research Laboratory, Washington, D. C. 20375#TAB#" id="2169367542">John McLean</author></authors><n_citation>79</n_citation><doc_type>Journal</doc_type><references><reference>27461577</reference><reference>203939441</reference><reference>1492921354</reference><reference>1528669307</reference><reference>1824487558</reference><reference>1882745535</reference><reference>1977764760</reference><reference>1982223289</reference><reference>1988698742</reference><reference>2080914957</reference><reference>2100019646</reference><reference>2101827827</reference><reference>2110050316</reference><reference>2111706174</reference><reference>2120670175</reference><reference>2129858673</reference><reference>2136898254</reference><reference>2164168555</reference><reference>2164886052</reference><reference>2168197734</reference></references><venue id="106992369" type="J">Journal of Computer Security</venue><doi>10.3233/JCS-1992-1103</doi><keywords><keyword weight="0.52878">Procedural programming</keyword><keyword weight="0.56033">Specification language</keyword><keyword weight="0.46324">Programming language</keyword><keyword weight="0.45063">Computer science</keyword><keyword weight="0.6165">Correctness</keyword><keyword weight="0.51464">Finite-state machine</keyword><keyword weight="0.44803">Theoretical computer science</keyword><keyword weight="0.5206">Software system</keyword><keyword weight="0.56008">Software requirements specification</keyword><keyword weight="0.53226">Software development</keyword><keyword weight="0.48494">Direct proof</keyword></keywords><publisher>IOS Press</publisher><abstract>The trace method of software specification is extended to provide a natural semantics for a procedural programming language. This extension provides a method for proving program correctness that permits a direct proof of program Noninterference without having to produce an intermediate finite state machine and unwinding conditions. This approach provides a uniform framework for reasoning about abstract software system specifications and their implementations. It also allows us to prove security at an abstract level so that changes to programs that do not affect functional behavior will not affect the security proof.</abstract></paper>