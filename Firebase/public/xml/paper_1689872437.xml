<paper id="1689872437"><title>Certifying Compilation and Run-Time Code Generation</title><year>1999</year><authors><author org="Computer and Information Science Department, University of Pennsylvania, Philadelphia, PA 19104, USA. hornof@cis.upenn.edu#TAB#" id="230507561">Luke Hornof</author><author org="Computer and Information Science Department, University of Pennsylvania, Philadelphia, PA 19104, USA. tjim@cis.upenn.edu#TAB#" id="2090299724">Trevor Jim</author></authors><n_citation>36</n_citation><doc_type /><references><reference>11600427</reference><reference>1480597667</reference><reference>1496885683</reference><reference>1532750793</reference><reference>1548093223</reference><reference>1552909716</reference><reference>1797198873</reference><reference>1810396090</reference><reference>1967235059</reference><reference>2000504947</reference><reference>2002181967</reference><reference>2009418036</reference><reference>2021951417</reference><reference>2051632385</reference><reference>2052170077</reference><reference>2059006730</reference><reference>2084475036</reference><reference>2088019269</reference><reference>2096314727</reference><reference>2097166325</reference><reference>2106445678</reference><reference>2106861521</reference><reference>2107202938</reference><reference>2151480972</reference><reference>2171691057</reference><reference>2294365706</reference></references><venue id="" type="">Higher-Order and Symbolic Computation archive</venue><doi>10.1023/A:1010039502678</doi><keywords><keyword weight="0.66038">Unreachable code</keyword><keyword weight="0.70325">Object code</keyword><keyword weight="0.669">Dead code elimination</keyword><keyword weight="0.46499">Programming language</keyword><keyword weight="0.4548">Computer science</keyword><keyword weight="0.67109">Source code</keyword><keyword weight="0.64469">Compiler</keyword><keyword weight="0.68116">Code generation</keyword><keyword weight="0.66504">Proof-carrying code</keyword><keyword weight="0.65443">Dead code</keyword></keywords><publisher>Kluwer Academic Publishers</publisher><abstract>A certifying compiler takes a source language program and produces object code, as well as a “certificate” that can be used to verify that the object code satisfies desirable properties, such as type safety and memory safety. Certifying compilation helps to increase both compiler robustness and program safety. Compiler robustness is improved since some compiler errors can be caught by checking the object code against the certificate immediately after compilation. Program safety is improved because the object code and certificate alone are sufficient to establish safety: even if the object code and certificate are produced on an unknown machine by an unknown compiler and sent over an untrusted network, safe execution is guaranteed as long as the code and certificate pass the :[122],"work in certifying compilation has addressed statically generated code. In this paper, we extend this to code generated at run time. Our goal is to combine certifying compilation with run-time code generation to produce programs that are both fast and verifiably safe. To achieve this goal, we present two new languages with explicit run-time code generation constructs: Cyclone, a type safe dialect of C, and TAL/T, a type safe assembly language. We have designed and implemented a system that translates a safe C program into Cyclone, which is then compiled to TAL/T, and finally assembled into executable object code. This paper focuses on our overall approach and the front end of our systems details about TAL/T will appear in a subsequent paper.</abstract></paper>