<paper id="1954776415"><title>A Compositional Semantics for Concurrent Prolog</title><year>1988</year><authors><author org="Centre for Mathematics and Computer Science" id="2663712106">Joost N. Kok</author></authors><n_citation>16</n_citation><doc_type>Conference</doc_type><references><reference>82671475</reference><reference>108763789</reference><reference>1607619406</reference><reference>2003531456</reference><reference>2063236708</reference><reference>2076248384</reference><reference>2085592760</reference><reference>2129802691</reference><reference>2129965117</reference><reference>2143382644</reference></references><venue id="1178070762" type="C">Symposium on Theoretical Aspects of Computer Science</venue><doi>10.1007/BFb0035860</doi><keywords><keyword weight="0.49846">Principle of compositionality</keyword><keyword weight="0.4724">Programming language</keyword><keyword weight="0.45949">Computer science</keyword><keyword weight="0.60094">Concurrency</keyword><keyword weight="0.54298">Deadlock</keyword><keyword weight="0.55152">Imperative programming</keyword><keyword weight="0.53101">Prolog</keyword><keyword weight="0.56665">Logic programming</keyword><keyword weight="0.49882">Semantics</keyword><keyword weight="0.5309">Recursion</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Concurrent logic languages like Concurrent Prolog have mechanisms in common with imperative concurrent languages: concurrency, communication, synchronization and indeterminacy, finite and infinite behaviour. A goal statement can be considered as a network of processes which run in parallel and can communicate. For imperative concurrent languages a lot of research on the semantics has been done. In this paper we show that a model, which was originally designed for imperative languages, can be used to give a formal description of Concurrent Prolog. This model is compositional: for any two conjunctions C1, C2 the meaning of C1 â‹€ C2 can be obtained by applying a function to the meanings of C1 and C2. To be more specific: we shall employ a domain where some choices made during the computation are recorded in certain tree-like structures, and which allows for interleaving. We use tree like structures because it is not possible to use flat structures (like traces or sequences of substitutions). They do not contain enough information to handle deadlock or infinite computations. Such phenomena require that we know at a certain moment in time all the alternatives. The domain is obtained as a solution of a domain equation. We apply metric topological tools to find a solution of the domain equation, and to define operations on elements of the domain. The semantic function maps goals, given a program P, to elements of the domain. This function is defined recursively. The model is able to handle both finite and infinite computations.</abstract></paper>