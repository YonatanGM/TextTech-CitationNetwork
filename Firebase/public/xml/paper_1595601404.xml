<paper id="1595601404"><title>A Statically Allocated Parallel Functional Language</title><year>2000</year><authors><author org="AT&amp;T Laboratories, Cambridge," id="163000670">Alan Mycroft</author><author org="AT&amp;T Laboratories, Cambridge," id="2161161904">Richard Sharp</author></authors><n_citation>39</n_citation><doc_type>Conference</doc_type><references><reference>1581217527</reference><reference>1799755858</reference><reference>1829244603</reference><reference>1853445766</reference><reference>2003131643</reference><reference>2023299380</reference><reference>2049600101</reference><reference>2105438076</reference><reference>2118883965</reference><reference>2127302556</reference></references><venue id="1141821850" type="C">International Colloquium on Automata, Languages and Programming</venue><doi>10.1007/3-540-45022-X_5</doi><keywords><keyword weight="0.50228">Primitive recursive function</keyword><keyword weight="0.4934">Program transformation</keyword><keyword weight="0.45834">Programming language</keyword><keyword weight="0.49809">Functional programming</keyword><keyword weight="0.44428">Computer science</keyword><keyword weight="0.49208">Compiler</keyword><keyword weight="0.43357">Interpreter</keyword><keyword weight="0.46812">Register machine</keyword><keyword weight="0.47301">Abstract machine</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We describe SAFL, a call-by-value first-order functional language which is syntactically restricted so that storage may be statically allocated to fixed locations. Evaluation of independent subexpressions happens in parallel--we use locking techniques to protect shared-use function definitions (i.e. to prevent unrestricted parallel accesses to their storage locations for argument and return values). SAFL programs have a well defined notion of total (program and data) size which we refer to as u0027areau0027; similarly we can talk about execution u0027timeu0027. Fold/unfold transformations on SAFL provide mappings between different points on the area-time spectrum. The space of functions expressible in SAFL is incomparable with the space of primitive recursive functions, in particular interpreters are expressible. The motivation behind SAFL is hardware description and synthesis--we have built an optimising compiler for translating SAFL to silicon.</abstract></paper>