<paper id="1546081490"><title>Early Identification of Incompatibilities in Multi-component Upgrades</title><year>2004</year><authors><author org="Computer Science and Artificial Intelligence Laboratory" id="2271153937">Stephen McCamant</author><author org="Computer Science and Artificial Intelligence Laboratory" id="2235702021">Michael D. Ernst</author></authors><n_citation>39</n_citation><doc_type>Conference</doc_type><references><reference>1575308494</reference><reference>1970495662</reference><reference>1975255815</reference><reference>1992431017</reference><reference>1995008247</reference><reference>2036656026</reference><reference>2038497675</reference><reference>2040856861</reference><reference>2051632385</reference><reference>2055477538</reference><reference>2059295282</reference><reference>2066210260</reference><reference>2080573945</reference><reference>2103318645</reference><reference>2109452325</reference><reference>2112694783</reference><reference>2121376435</reference><reference>2151191515</reference><reference>2171339374</reference><reference>2173184982</reference></references><venue id="1177184315" type="C">European Conference on Object-Oriented Programming</venue><doi>10.1007/978-3-540-24851-4_20</doi><keywords><keyword weight="0.4869">Test suite</keyword><keyword weight="0.47099">Object-oriented programming</keyword><keyword weight="0.44834">Computer science</keyword><keyword weight="0.50795">Unix</keyword><keyword weight="0.48923">Upgrade</keyword><keyword weight="0.47434">Callback</keyword><keyword weight="0.51161">Component-based software engineering</keyword><keyword weight="0.4901">Software development</keyword><keyword weight="0.44717">Operating system</keyword><keyword weight="0.45576">Special case</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Previous work proposed a technique for predicting problems resulting from replacing one version of a software component by another. The technique reports, before performing the replacement or integrating the new component into a system, whether the upgrade might be problematic for that particular system. This paper extends the technique to make it more applicable to object-oriented systems and real-world upgrades. First, we extend the theoretical framework to handle more complex upgrades, including components with internal state, callbacks, and simultaneous upgrades of multiple components. The old model is a special case of our new one. Second, we show how to handle four real-world situations that were not addressed by previous work: non-local state, non-determinism, distinguishing old from new incompatibilities, and lack of test suites. Third, we present a case study in which we upgrade the Linux C library, for 48 Unix programs. Our implementation identified real incompatibilities among versions of the C library that affected some of the programs, and it approved the upgrades for other programs that were unaffected by the changes.</abstract></paper>