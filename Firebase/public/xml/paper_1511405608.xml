<paper id="1511405608"><title>What went wrong: explaining counterexamples</title><year>2003</year><authors><author org="Dept. of Computer Science, Carnegie Mellon University, Pittsburgh, PA#TAB#" id="1965603299">Alex Groce</author><author org="RIACS/NASA Ames Res. Center, Moffett Field, CA" id="2610259858">Willem Visser</author></authors><n_citation>169</n_citation><doc_type>Conference</doc_type><references><reference>1991339794</reference><reference>2034797990</reference><reference>2089139117</reference><reference>2103318645</reference><reference>2119826996</reference><reference>2121081915</reference><reference>2121461840</reference><reference>2154606260</reference><reference>2158870716</reference><reference>2169134334</reference><reference>2170224888</reference><reference>2171480813</reference><reference>2295903414</reference><reference>2340735175</reference></references><venue id="2760802481" type="C">International workshop on Model Checking Software</venue><doi>10.1007/3-540-44829-2_8</doi><keywords><keyword weight="0.49027">Model checking</keyword><keyword weight="0.43594">Programming language</keyword><keyword weight="0.43217">Scheduling (computing)</keyword><keyword weight="0.44419">Computer science</keyword><keyword weight="0.4674">Source code</keyword><keyword weight="0.43241">Theoretical computer science</keyword><keyword weight="0.40108">Invariant (mathematics)</keyword><keyword weight="0.43924">Counterexample</keyword><keyword weight="0.0">Design analysis</keyword><keyword weight="0.44827">Computer programming</keyword><keyword weight="0.41887">Distributed computing</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>One of the chief advantages of model checking is the production of counterexamples demonstrating that a system does not satisfy a specification. However, it may require a great deal of human effort to extract the essence of an error from even a detailed source-level trace of a failing run. We use an automated method for finding multiple versions of an error (and similar executions that do not produce an error), and analyze these executions to produce a more succinct description of the key elements of the error. The description produced includes identification of portions of the source code crucial to distinguishing failing and succeeding runs, differences in invariants between failing and nonfailing runs, and information on the necessary changes in scheduling and environmental actions needed to cause successful runs to fail.</abstract></paper>