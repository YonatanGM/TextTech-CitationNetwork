<paper id="1787838883"><title>Modeling concurrency by partial orders and nonlinear transition systems</title><year>1988</year><authors><author org="Hebrew university, Jerusalem, Israel#TAB#" id="234059693">Haim Gaifman</author></authors><n_citation>20</n_citation><doc_type /><references><reference>84232747</reference><reference>178058081</reference><reference>1524234654</reference><reference>1597671168</reference><reference>1897234491</reference><reference>1967736886</reference><reference>2001748564</reference><reference>2045370304</reference><reference>2046381502</reference><reference>2056740525</reference><reference>2110425399</reference><reference>2113355185</reference><reference>2150320481</reference></references><venue id="" type="">Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, School/Workshop</venue><doi>10.1007/BFb0013031</doi><keywords><keyword weight="0.52783">Transition system</keyword><keyword weight="0.43475">Discrete mathematics</keyword><keyword weight="0.46918">Nonlinear system</keyword><keyword weight="0.44832">Computer science</keyword><keyword weight="0.59607">Concurrency</keyword><keyword weight="0.47966">Automaton</keyword><keyword weight="0.5484">Deadlock</keyword><keyword weight="0.46164">Theoretical computer science</keyword><keyword weight="0.45579">Shared resource</keyword><keyword weight="0.5046">Simultaneity</keyword><keyword weight="0.52599">Dining philosophers problem</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>In the first part we give a general analysis of concurrency. We model computations as structures over multisets of actions with two strict partial orders: causal precedence (in a wide sense of “causal”) and temporal precedence. The first is included in the second. Concurrent events are those incomparable under causal precedence, simultaneous events are those incomparable under temporal precedence. Thus, simultaneity implies concurrency but not vice versa. In this setting we can define precisely how computing devices are specified by partial orders and how pomsets express concurrency. The causal parts of the possible computations of a computing device constitute the core of the corresponding process. They turn out to be the least constrained members in the set of pomsets which specifies the device. The core of the process is insensitive to the way we model time and events, the temporal components are not. In the second part of the work we propose a generalization of linear transition systems. The nonlinear systems act like automata that spew out pomsets instead of strings. Various intuitions can be carried over from the linear to the nonlinear case without sacrificing true concurrency. Nonlinear automata can be used to generate the cores of processes associated with a great variety of computing devices. In particular, we show how they provide useful descriptions of shared resource situations (Dining Philosophers with and without Locking). The avoidance of deadlock by an implementation can be defined and proved. Similarly, we can define formally what it means for an implementation to involve loss of parallelism. Such a loss shows in the form of extra order constraints that have to be added to core members of the original process. Nonlinear transition systems appear to be natural candidates for modeling concurrency and hidden branching within a manageable framework.</abstract></paper>