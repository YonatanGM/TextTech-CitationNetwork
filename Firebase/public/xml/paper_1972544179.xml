<paper id="1972544179"><title>Eraser: a dynamic data race detector for multithreaded programs</title><year>1997</year><authors><author org="University of Washington-Seattle," id="2171030022">Stefan Savage</author><author org="Digital Equipment Corp., Palo Alto, CA" id="2302774460">Michael Burrows</author><author org="Digital Equipment Corp., Palo Alto, CA" id="2606658143">Greg Nelson</author><author org="Digital Equipment Corp., Palo Alto, CA" id="2683979819">Patrick Sobalvarro</author><author org="University of California at Berkeley, Berkeley," id="2148869393">Thomas Anderson</author></authors><n_citation>1303</n_citation><doc_type>Journal</doc_type><references><reference>1973501242</reference><reference>2005031208</reference><reference>2019611783</reference><reference>2022185456</reference><reference>2047226031</reference><reference>2061239425</reference><reference>2083469471</reference><reference>2107995193</reference><reference>2111763551</reference><reference>2124288146</reference><reference>2131791649</reference><reference>2141318181</reference><reference>2162446957</reference><reference>2170200862</reference></references><venue id="193109227" type="J">ACM Transactions on Computer Systems</venue><doi>10.1145/265924.265927</doi><keywords><keyword weight="0.46388">Web search engine</keyword><keyword weight="0.54711">Race condition</keyword><keyword weight="0.44755">Synchronization</keyword><keyword weight="0.45406">Programming language</keyword><keyword weight="0.474">Mistake</keyword><keyword weight="0.45392">Computer science</keyword><keyword weight="0.43809">Real-time computing</keyword><keyword weight="0.46711">Thread (computing)</keyword><keyword weight="0.45467">Bebugging</keyword><keyword weight="0.48081">Dynamic data</keyword><keyword weight="0.50166">Debugging</keyword><keyword weight="0.44076">Distributed computing</keyword></keywords><publisher>ACM</publisher><abstract>Multithreaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This article describes a new tool, called Eraser, for dynamically detecting data races in lock-based multithreaded programs. Eraser uses binary rewriting techniques to monitor every shared-monory reference and verify that consistent locking behavior is observed. We present several case studies, including undergraduate coursework and a multithreaded Web search engine, that demonstrate the effectiveness of this approach.</abstract></paper>