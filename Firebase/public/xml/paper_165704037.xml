<paper id="165704037"><title>Negation in logic programming: A formalization in constructive logic</title><year>1990</year><authors><author org="ECRC" id="870525885">François Bry</author></authors><n_citation>24</n_citation><doc_type /><references><reference>1543252330</reference><reference>1570025952</reference><reference>1672891595</reference><reference>1849174213</reference><reference>1966552757</reference><reference>1968513265</reference><reference>1976303542</reference><reference>1981961379</reference><reference>1983305931</reference><reference>1984715534</reference><reference>1999410326</reference><reference>2003531456</reference><reference>2010160994</reference><reference>2045058631</reference><reference>2070553391</reference><reference>2100264125</reference><reference>2100738443</reference><reference>2105505307</reference><reference>2108911687</reference><reference>2111353076</reference><reference>2118210775</reference><reference>2132745831</reference><reference>2147096558</reference><reference>2149109323</reference><reference>2155322595</reference><reference>2911865844</reference></references><venue id="" type="">Workshop on Information Systems and Artificial Intelligence</venue><doi>10.1007/3-540-53557-8_20</doi><keywords><keyword weight="0.68551">Computational logic</keyword><keyword weight="0.68562">Horn clause</keyword><keyword weight="0.71488">Autoepistemic logic</keyword><keyword weight="0.45217">Programming language</keyword><keyword weight="0.69183">Multimodal logic</keyword><keyword weight="0.70615">Logic programming</keyword><keyword weight="0.69571">Philosophy of logic</keyword><keyword weight="0.68705">Predicate functor logic</keyword><keyword weight="0.68261">Many-valued logic</keyword><keyword weight="0.39832">Mathematics</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>The conventional formalization of logic programming in classical logic explains very convincingly the basic principles of this programming style. However, it gives no easy or intuitive explanations for the treatment of negation. Logic Programming handles negation through the so-called “Negation as Failure” inference principle which is rather unconventional from the viewpoint of classical logic. Despite its nonclassical nature, this inference principle cannot be avoided in practice. The appropriate application of Negation as Failure requires either syntactical restrictions, or significant changes in the semantics of logic programs. In this article, we defend the thesis that these syntactical restrictions or semantical changes are naturally and simply explained by observing that logic programming in fact implements no more than a constructive fragment of classical logic. Relying on a “Conditional Fixpoint Procedure”, we first define a monotonic inference procedure for logic programs with negation that are consistent in this constructive fragment. Then we show how this procedure can be extended into a “Ternary Fixpoint Procedure” for general programs. This fixpoint procedure defines a ternary logic semantics for syntactically unrestricted logic programs. Finally, we argue that the constructive interpretation of logic programming also gives a simple and natural explanation of meta-programming. Relying on this view of meta-programming, we specify different forms of reflective reasoning, in particular default reasoning.</abstract></paper>