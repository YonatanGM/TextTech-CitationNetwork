<paper id="1973162794"><title>No assembly required: compiling standard ML to C</title><year>1992</year><authors><author org="Carnegie Mellon University, Pittsburgh Pa" id="2118028040">David Tarditi</author><author org="Carnegie Mellon University, Pittsburgh Pa" id="2139030624">Peter Lee</author><author org="Carnegie Mellon University, Pittsburgh Pa" id="2155302952">Anurag Acharya</author></authors><n_citation>90</n_citation><doc_type>Journal</doc_type><references><reference>1491178396</reference><reference>1557045049</reference><reference>1829244603</reference><reference>1973165589</reference><reference>1979240050</reference><reference>2002301065</reference><reference>2005347835</reference><reference>2033571435</reference><reference>2083697466</reference><reference>2114922959</reference><reference>2133979298</reference><reference>2159389028</reference><reference>2611598995</reference><reference>2912126004</reference></references><venue id="185931187" type="J">ACM Letters on Programming Languages and Systems</venue><doi>10.1145/151333.151343</doi><keywords><keyword weight="0.59575">Common Intermediate Language</keyword><keyword weight="0.65333">Dynamic compilation</keyword><keyword weight="0.4598">Programming language</keyword><keyword weight="0.60914">Compile time</keyword><keyword weight="0.4327">Computer science</keyword><keyword weight="0.44273">Parallel computing</keyword><keyword weight="0.62422">Code generation</keyword><keyword weight="0.64285">Compiler</keyword><keyword weight="0.63649">Single Compilation Unit</keyword><keyword weight="0.61377">Tracing just-in-time compilation</keyword><keyword weight="0.58737">Interpreted language</keyword></keywords><publisher>ACM</publisher><abstract>C has been used as a portable target language for implementing languages like Standard ML and Scheme. Previous efforts at compiling these languages to C have produced efficient code, but have compromised on portability and proper tail recursion. We show how to compile Standard ML to C wihout making such compromises. The compilation technique is based on converting Standard ML to a continuation-passing style Î»-calculus intermediate language and then compiling this language to C. The code generated by this compiler achieves an execution speed that is about a factor of two slower than that generated by a native code compiler. The compiler generates highly portable code, yet still supports advanced features like garbage collection and first-class continuations. We analyze the performance and determine the aspects of the compilation method that lead to the observed slowdown. We also suggest changes to C compilers that would better support such compilation methods.</abstract></paper>