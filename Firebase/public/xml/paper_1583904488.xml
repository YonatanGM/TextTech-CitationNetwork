<paper id="1583904488"><title>Eliminating Stack Overflow by Abstract Interpretation</title><year>2003</year><authors><author org="University of Utah ," id="1993899960">John Regehr</author><author org="University of Utah ," id="2293162450">Alastair Reid</author><author org="University of Utah ," id="2149622386">Kirk Webb</author></authors><n_citation>5</n_citation><doc_type>Conference</doc_type><references><reference>1480779880</reference><reference>1546496162</reference><reference>1582456956</reference><reference>1907234304</reference><reference>1965864973</reference><reference>1971903460</reference><reference>2004633100</reference><reference>2035216234</reference><reference>2043100293</reference><reference>2096396200</reference><reference>2104532741</reference><reference>2106202449</reference><reference>2125076295</reference><reference>2133222776</reference><reference>2164164245</reference><reference>2165850270</reference><reference>2293873148</reference></references><venue id="1162226489" type="C">Embedded Software</venue><doi>10.1007/978-3-540-45212-6_20</doi><keywords><keyword weight="0.55886">Embedded software</keyword><keyword weight="0.44977">Computer science</keyword><keyword weight="0.73382">Call stack</keyword><keyword weight="0.65652">Stack register</keyword><keyword weight="0.45953">Real-time computing</keyword><keyword weight="0.73904">Stack trace</keyword><keyword weight="0.51719">Machine code</keyword><keyword weight="0.51065">Microcontroller</keyword><keyword weight="0.50505">Program analysis</keyword><keyword weight="0.68106">Stack-based memory allocation</keyword><keyword weight="0.46903">Embedded system</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>An important correctness criterion for software running on embedded microcontrollers is stack safety: a guarantee that the call stack does not overflow. We address two aspects of the problem of creating stack-safe embedded software that also makes efficient use of memory: statically bounding worst-case stack depth, and automatically reducing stack memory requirements. Our first contribution is a method for statically guaranteeing stack safety by performing whole-program analysis, using an approach based on context-sensitive abstract interpretation of machine code. Abstract interpretation permits our analysis to accurately model when interrupts are enabled and disabled, which is essential for accurately bounding the stack depth of typical embedded systems. We have implemented a stack analysis tool that targets Atmel AVR microcontrollers, and tested it on embedded applications compiled from up to 30,000 lines of C . We experimentally validate the accuracy of the tool, which runs in a few seconds on the largest programs that we tested. The second contribution of this paper is a novel framework for automatically reducing stack memory requirements. We show that goal-directed global function inlining can be used to reduce the stack memory requirements of component-based embedded software, on average, to 40% of the requirement of a system compiled without inlining, and to 68% of the requirement of a system compiled with aggressive whole-program inlining that is not directed towards reducing stack usage.</abstract></paper>