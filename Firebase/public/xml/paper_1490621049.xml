<paper id="1490621049"><title>Towards an ML-Style Polymorphic Type System for C</title><year>1996</year><authors><author org="Florida International University" id="2159366204">Geoffrey Smith</author><author org="Naval Postgraduate School,," id="199750138">Dennis M. Volpano</author></authors><n_citation>11</n_citation><doc_type>Conference</doc_type><references><reference>1593666219</reference><reference>1971933951</reference><reference>1997282149</reference><reference>2030916392</reference><reference>2052822938</reference><reference>2110135416</reference><reference>2151156765</reference><reference>2163976959</reference><reference>2169761811</reference><reference>2611598995</reference></references><venue id="1136861413" type="C">European Symposium on Programming</venue><doi>10.1007/3-540-61055-3_47</doi><keywords><keyword weight="0.61779">Pointer (computer programming)</keyword><keyword weight="0.59318">Type system</keyword><keyword weight="0.43709">Programming language</keyword><keyword weight="0.60946">Type signature</keyword><keyword weight="0.58214">Enumerated type</keyword><keyword weight="0.41378">Computer science</keyword><keyword weight="0.56417">Imperative programming</keyword><keyword weight="0.60176">Type inference</keyword><keyword weight="0.42387">Theoretical computer science</keyword><keyword weight="0.57347">Data type</keyword><keyword weight="0.57141">Type safety</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Advanced polymorphic type systems have come to play an important role in the world of functional programming. But, curiously, these type systems have so far had little impact upon widely-used imperative programming languages like C and C++. We show that ML-style polymorphism can be integrated smoothly into a dialect of C, which we call Polymorphic C. It has the same pointer operations as C, including the address-of operator u0026, the dereferencing operator*, and pointer arithmetic. Our type system allows these operations in their full generality, so that programmers need not give up the flexibility of C to gain the benefits of ML-style polymorphism. We prove a type soundness theorem that gives a rigorous and useful characterization of well-typed Polymorphic C programs in terms of what can go wrong when they are evaluated.</abstract></paper>