<paper id="1743041603"><title>Transforming Haskell for tracing</title><year>2002</year><authors><author org="The University of York, UK" id="301443495">Olaf Chitil</author><author org="The University of York, UK" id="711150104">Colin Runciman</author><author org="The University of York, UK" id="2464682470">Malcolm Wallace</author></authors><n_citation>33</n_citation><doc_type>Conference</doc_type><references><reference>1490584728</reference><reference>1600253083</reference><reference>1841915623</reference><reference>2038856365</reference><reference>2140499691</reference></references><venue id="1132577199" type="C">Implementation and Application of Functional Languages</venue><doi>10.1007/3-540-44854-3_11</doi><keywords><keyword weight="0.57397">Foreign function interface</keyword><keyword weight="0.47037">Programming language</keyword><keyword weight="0.58103">Program transformation</keyword><keyword weight="0.56502">Functional programming</keyword><keyword weight="0.44039">Computer science</keyword><keyword weight="0.5422">Compiler</keyword><keyword weight="0.75868">Haskell</keyword><keyword weight="0.52313">Program comprehension</keyword><keyword weight="0.49161">Computer programming</keyword><keyword weight="0.49377">Debugging</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Hat is a programmeru0027s tool for generating a trace of a computation of a Haskell 98 program and viewing such a trace in various different ways. Applications include program comprehension and debugging. A new version of Hat uses a stand-alone program transformation to produce self-tracing Haskell programs. The transformation is small and works with any Haskell 98 compiler that implements the standard foreign function interface. We present general techniques for building compiler independent tools similar to Hat based on program transformation. We also point out which features of Haskell 98 caused us particular grief.</abstract></paper>