<paper id="1972427803"><title>A schema for interprocedural modification side-effect analysis with pointer aliasing</title><year>2001</year><authors><author org="Rutgers University" id="2139647612">Barbara G. Ryder</author><author org="Siemens Corporate Research, Inc," id="2033631000">William A. Landi</author><author org="Rutgers University" id="2230376541">Philip A. Stocks</author><author org="Rutgers University" id="2097856236">Sean Zhang</author><author org="Rutgers University" id="1994478659">Rita Altucher</author></authors><n_citation>85</n_citation><doc_type>Journal</doc_type><references><reference>19247575</reference><reference>110734221</reference><reference>1491178396</reference><reference>1518169998</reference><reference>1556425961</reference><reference>1575308494</reference><reference>1577294234</reference><reference>1602885681</reference><reference>1710250545</reference><reference>1797940162</reference><reference>1966360373</reference><reference>1966449927</reference><reference>1970061809</reference><reference>1974604404</reference><reference>1975514564</reference><reference>1975914482</reference><reference>1977380916</reference><reference>1981577498</reference><reference>1982527649</reference><reference>1984914680</reference><reference>1985614269</reference><reference>1986347924</reference><reference>1986703553</reference><reference>1996094959</reference><reference>1996146601</reference><reference>1997474908</reference><reference>2002771912</reference><reference>2004378344</reference><reference>2004419599</reference><reference>2009911326</reference><reference>2016079676</reference><reference>2016558072</reference><reference>2017785995</reference><reference>2019386850</reference><reference>2019709986</reference><reference>2020841721</reference><reference>2021986357</reference><reference>2022043656</reference><reference>2022363576</reference><reference>2023222549</reference><reference>2028536280</reference><reference>2030697178</reference><reference>2031364891</reference><reference>2036555984</reference><reference>2045693727</reference><reference>2048639238</reference><reference>2048683749</reference><reference>2050903618</reference><reference>2053152889</reference><reference>2053155313</reference><reference>2054120966</reference><reference>2055084740</reference><reference>2056289513</reference><reference>2057085278</reference><reference>2060910994</reference><reference>2062764376</reference><reference>2068549754</reference><reference>2074954052</reference><reference>2075055870</reference><reference>2077102566</reference><reference>2077617866</reference><reference>2080573945</reference><reference>2087612811</reference><reference>2088126145</reference><reference>2091141964</reference><reference>2095115578</reference><reference>2096139068</reference><reference>2096587139</reference><reference>2098645109</reference><reference>2102010769</reference><reference>2102440514</reference><reference>2103326816</reference><reference>2110019745</reference><reference>2111695742</reference><reference>2113238444</reference><reference>2120339017</reference><reference>2124153277</reference><reference>2124300773</reference><reference>2131135493</reference><reference>2134691366</reference><reference>2135697103</reference><reference>2138986001</reference><reference>2139356751</reference><reference>2140152108</reference><reference>2142840915</reference><reference>2145913834</reference><reference>2146528052</reference><reference>2147088720</reference><reference>2151360539</reference><reference>2152954816</reference><reference>2156528699</reference><reference>2156549049</reference><reference>2162046779</reference><reference>2162310108</reference><reference>2166341446</reference><reference>2293624369</reference></references><venue id="41449414" type="J">ACM Transactions on Programming Languages and Systems</venue><doi>10.1145/383043.381532</doi><keywords><keyword weight="0.50951">Pointer (computer programming)</keyword><keyword weight="0.46199">Parameterized complexity</keyword><keyword weight="0.4663">Mod</keyword><keyword weight="0.41372">Programming language</keyword><keyword weight="0.40456">Computer science</keyword><keyword weight="0.5586">Pointer aliasing</keyword><keyword weight="0.44608">Algorithm</keyword><keyword weight="0.45573">Aliasing</keyword><keyword weight="0.41912">Ranging</keyword><keyword weight="0.53318">Alias analysis</keyword><keyword weight="0.40315">Order of magnitude</keyword></keywords><publisher>ACM</publisher><abstract>The first interprocedural modification side-effects analysis for C (MOD C ) that obtains better than worst-case precision on programs with general-purpose pointer usage is presented with empirical results. The analysis consists of an algorithm schema corresponding to a family of MOD C algorithms with two independent phases: one for determining pointer-induced aliases and a subsequent one for propagating interprocedural side effects. These MOD C algorithms are parameterized by the aliasing method used. The empirical results compare the performance of two dissimilar MOD C algorithms: MOD C ( FSAlias ) uses a flow-sensitive, calling-context-sensitive interprocedural alias analysis; MOD C ( FIAlias uses a flow-insensitive, calling-context-insensitive alias analysis which is much faster, but less accurate. These two algorithms were profiled on 45 programs ranging in size from 250 to 30,000 lines of C code, and the results demonstrate dramatically the possible cost-precision trade-offs. This first comparative implementation of MOD C analyses offers insight into the differences between flow-/context-sensitive and flow-/context-insensitive analyses. The analysis cost versus precision trade-offs in side-effect information obtained are reported. The results show surprisingly that the precision of flow-sensitive side-effect analysis is not always prohibitive in cost, and that the precision of flow-insensitive analysis is substantially better than worst-case estimates and seems sufficient for certain applications. On average MOD C ( FSAlias ) for procedures and calls is in the range of 20% more precise than MOD C ( FIAlias ); however, the performance was found to be at least an order of magnitude slower than MOD C ( FIAlias ).</abstract></paper>