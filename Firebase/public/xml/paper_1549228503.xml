<paper id="1549228503"><title>A Design Principle for Hash Functions</title><year>1989</year><authors><author org="" id="2682364181">Ivan Bjerre Damg√•rd</author></authors><n_citation>900</n_citation><doc_type>Conference</doc_type><references><reference>1493969756</reference><reference>1495724987</reference><reference>1508014175</reference><reference>1522255819</reference><reference>1541421768</reference><reference>1600432225</reference><reference>1972792640</reference><reference>2016477241</reference><reference>2166457424</reference></references><venue id="1153524033" type="C">International Cryptology Conference</venue><doi>10.1007/0-387-34805-0_39</doi><keywords><keyword weight="0.59298">SHA-2</keyword><keyword weight="0.47037">Discrete mathematics</keyword><keyword weight="0.60458">Double hashing</keyword><keyword weight="0.63316">Collision resistance</keyword><keyword weight="0.43293">Theoretical computer science</keyword><keyword weight="0.60059">SWIFFT</keyword><keyword weight="0.61207">Hash function</keyword><keyword weight="0.59075">Security of cryptographic hash functions</keyword><keyword weight="0.59155">Collision attack</keyword><keyword weight="0.4163">Mathematics</keyword><keyword weight="0.59543">MDC-2</keyword></keywords><publisher>Springer, New York, NY</publisher><abstract>We show that if there exists a computationally collision free function f from m bits to t bits where m u003e t, then there exists a computationally collision free function h mapping messages of arbitrary polynomial lengths to t-bit strings.Let n be the length of the message, h can be constructed either such that it can be evaluated in time linear in n using 1 processor, or such that it takes time O(log(n)) using O(n) processors, counting evaluations of f as one step. Finally, for any constant k and large n, a speedup by a factor of k over the first construction is available using k processors.Apart from suggesting a generally sound design principle for hash functions, our results give a unified view of several apparently unrelated constructions of hash functions proposed earlier. It also suggests changes to other proposed constructions to make a proof of security potentially easier.We give three concrete examples of constructions, based on modular squaring, on Wolframu0027s pseudoranddom bit generator [Wo], and on the knapsack problem.</abstract></paper>