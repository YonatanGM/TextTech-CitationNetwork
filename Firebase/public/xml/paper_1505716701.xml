<paper id="1505716701"><title>How many oblivious transfers are needed for secure multiparty computation</title><year>2007</year><authors><author org="Department of Computer Science , Technion , Haifa, Israel" id="204190299">Danny Harnik</author><author org="Department of Computer Science , Technion , Haifa, Israel" id="114908009">Yuval Ishai</author><author org="Department of Computer Science , Technion , Haifa, Israel" id="307687659">Eyal Kushilevitz</author></authors><n_citation>17</n_citation><doc_type>Conference</doc_type><references><reference>44936433</reference><reference>173953576</reference><reference>294914909</reference><reference>1487501992</reference><reference>1488169517</reference><reference>1500727361</reference><reference>1502935422</reference><reference>1521679698</reference><reference>1526970571</reference><reference>1560855680</reference><reference>1580656816</reference><reference>1582319069</reference><reference>1584785281</reference><reference>1797136128</reference><reference>1847291654</reference><reference>1968010535</reference><reference>1982146060</reference><reference>1984459117</reference><reference>1987667503</reference><reference>1996068512</reference><reference>1997859100</reference><reference>1998058955</reference><reference>1999522397</reference><reference>2003406796</reference><reference>2004881597</reference><reference>2011112377</reference><reference>2014199040</reference><reference>2016443801</reference><reference>2019656970</reference><reference>2035532007</reference><reference>2048958388</reference><reference>2065626264</reference><reference>2069673227</reference><reference>2077135340</reference><reference>2098487689</reference><reference>2114702110</reference><reference>2119422255</reference><reference>2123025883</reference><reference>2136616826</reference><reference>2143222367</reference><reference>2168957864</reference><reference>2610806740</reference><reference>2728487654</reference></references><venue id="1153524033" type="C">International Cryptology Conference</venue><doi>10.1007/978-3-540-74143-5_16</doi><keywords><keyword weight="0.43017">Discrete mathematics</keyword><keyword weight="0.5301">Secure multi-party computation</keyword><keyword weight="0.45133">Expander graph</keyword><keyword weight="0.40725">Exponential function</keyword><keyword weight="0.42019">Computer science</keyword><keyword weight="0.0">Computational security</keyword><keyword weight="0.42166">Communication channel</keyword><keyword weight="0.508">Communication complexity</keyword><keyword weight="0.42864">Theoretical computer science</keyword><keyword weight="0.52982">Security parameter</keyword><keyword weight="0.56625">Oblivious transfer</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Oblivious transfer (OT) is an essential building block for secure multiparty computation when there is no honest majority. In this setting, current protocols for n ≥ 3 parties require each pair of parties to engage in a single OT for each gate in the circuit being evaluated. Since implementing OT typically requires expensive public-key operations (alternatively, expensive setup or physical infrastructure), minimizing the number of OTs is a highly desirable this :[70],"work we initiate a study of this problem in both an information-theoretic and a computational setting and obtain the following results. - If the adversary can corrupt up to t = (1 - Ɛ)n parties, where Ɛ ≥ 0 is an arbitrarily small constant, then a total of O(n) OT channels between pairs of parties are necessary and sufficient for general secure computation. Combined with previous protocols for "extending OTs", O(nk) invocations of OT are sufficient for computing arbitrary functions with computational security, where k is a security parameter. - The above result does not improve over the previous state of the art in the important case where t = n - 1, when the number of parties is small, or in the information-theoretic setting. For these cases, we show that an arbitrary function f : {0, 1}n → {0, 1}* can be securely computed by a protocol which makes use of a single OT (of strings) between each pair of parties. This result is tight in the sense that at least one OT between each pair of parties is necessary in these cases. A major disadvantage of this protocol is that its communication complexity grows exponentially with n. We present natural classes of functions f for which this exponential overhead can be avoided.</abstract></paper>