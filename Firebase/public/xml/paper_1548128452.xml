<paper id="1548128452"><title>Towards Optimal Indexing for Segment Databases</title><year>1998</year><authors><author org="Universita’ Degli Studi di Milano" id="2924517261">Elisa Bertino</author><author org="Universita’ Degli Studi di Milano" id="2087930920">Barbara Catania</author><author org="Rank Xerox Research Center" id="2304981840">Boris Shidlovsky</author></authors><n_citation>7</n_citation><doc_type>Conference</doc_type><references><reference>25426087</reference><reference>1480905303</reference><reference>1493854191</reference><reference>1550742839</reference><reference>1994101999</reference><reference>2026166434</reference><reference>2029814178</reference><reference>2040772963</reference><reference>2061750047</reference><reference>2080663718</reference><reference>2085088576</reference><reference>2118269922</reference><reference>2142753649</reference><reference>2161694911</reference></references><venue id="1132593990" type="C">Extending Database Technology</venue><doi>10.1007/BFb0100976</doi><keywords><keyword weight="0.0">Internal memory</keyword><keyword weight="0.43637">Data structure</keyword><keyword weight="0.33693">Computer science</keyword><keyword weight="0.49429">Amortized analysis</keyword><keyword weight="0.40113">Search engine indexing</keyword><keyword weight="0.42159">Temporal database</keyword><keyword weight="0.46681">Time complexity</keyword><keyword weight="0.50752">Segment tree</keyword><keyword weight="0.32855">Database</keyword><keyword weight="0.4078">Auxiliary memory</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Segment databases store N non-crossing but possibly touching segments in secondary storage. Efficient data structures have been proposed to determine all segments intersecting a vertical line (stabbing queries). In this paper, we consider a more general type of query for segment databases, determining intersections with respect to a generalized segment (a line, a ray, a segment) with a fixed angular coefficient. We propose two solutions to solve this problem. The first solution has optimal O(N/B) space complexity, where N is the database size and B is the page size, but the query time is far from optimal. The second solution requires O(N/B log2 B) space, the query time is O(logB N/B(logB N/B+log2 B+IL * (B))+T/B), which is very close to the optimal, and insertion amortized time is O(logB N/B+log2 B+1/Blog2 B N/B), where T is the size of the query result, and IL * (B) is a small constant, representing the number of times we must repeatedly apply the log* function to B before the result becomes ≤ 2.</abstract></paper>