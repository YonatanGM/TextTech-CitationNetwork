<paper id="1822320350"><title>VIS: A System for Verification and Synthesis</title><year>1996</year><authors><author org="University of California" id="2038038819">Robert K. Brayton</author><author org="University of colorado." id="1982291508">Gary D. Hachtel</author><author org="University of California" id="681596721">Alberto L. Sangiovanni-Vincentelli</author><author org="University of colorado." id="208756671">Fabio Somenzi</author><author org="University of California" id="2917461269">Adnan Aziz</author><author org="University of California" id="2138191402">Szu-Tsung Cheng</author><author org="University of California" id="2157022553">Stephen A. Edwards</author><author org="University of California" id="2311031194">Sunil P. Khatri</author><author org="University of California" id="51384186">Yuji Kukimoto</author><author org="University of colorado." id="2102747298">Abelardo Pardo</author><author org="University of California" id="1985363956">Shaz Qadeer</author><author org="University of California" id="2311721705">Rajeev K. Ranjan</author><author org="Lattice Semiconductor" id="2280497130">Shaker Sarwary</author><author org="University of California" id="331188436">Thomas R. Shiple</author><author org="University of California" id="2166312396">Gitanjali Swamy</author><author org="University of California" id="2915415597">Tiziano Villa</author></authors><n_citation>539</n_citation><doc_type>Conference</doc_type><references><reference>2100112273</reference><reference>2155672011</reference><reference>2160991071</reference></references><venue id="1162450063" type="C">Computer Aided Verification</venue><doi>10.1007/3-540-61474-5_95</doi><keywords><keyword weight="0.61569">Formal equivalence checking</keyword><keyword weight="0.48264">Data structure</keyword><keyword weight="0.60437">Model checking</keyword><keyword weight="0.52423">Sequential logic</keyword><keyword weight="0.45468">Computer science</keyword><keyword weight="0.45675">Theoretical computer science</keyword><keyword weight="0.53613">Finite-state machine</keyword><keyword weight="0.51646">Equivalence (measure theory)</keyword><keyword weight="0.47657">Counterexample</keyword><keyword weight="0.53667">Formal verification</keyword></keywords><publisher>Springer-Verlag</publisher><abstract>ion Manual abstraction can be performed by giving a file containing the names of variables to abstract. For each variable appearing in the file, a new primary input node is created to drive all the nodes that were previously driven by the variable. Abstracting a net effectively allows it to take any value in its range, at every clock cycle. Fair CTL model checking and language emptiness check VIS performs fair CTL model checking under Buchi fairness constraints. In addition, VIS can perform language emptiness checking by model checking the formula EG true. The language of a design is given by sequences over the set of reachable states that do not violate the fairness constraint. The language emptiness check can be used to perform language containment by expressing the set of bad behaviors as another component of the system. If model checking or language emptiness fail, VIS reports the failure with a counterexample, (i.e., behavior seen in the system that does not satisfy the property for model checking, or valid behavior seen in the system for language emptiness). This is called the “debug” trace. Debug traces list a set of states that are on a path to a fair cycle and fail the CTL formula. Equivalence checking VIS provides the capability to check the combinational equivalence of two designs. An important usage of combinational equivalence is to provide a sanity check when re-synthesizing portions of a network. VIS also provides the capability to test the sequential equivalence of two designs. Sequential verification is done by building the product finite state machine, and checking whether a state where the values of two corresponding outputs differ, can be reached from the set of initial states of the product machine. If this happens, a debug trace is provided. Both combinational and sequential verification are implemented using BDD-based routines. Simulation VIS also provides traditionaldesign verification in the form of a cycle-based simulator that uses BDD techniques. Since VIS performs both formal verification and simulation using the same data structures, consistency between them is ensured. VIS can generate random input patterns or accept user-specified input patterns. Any subtree of the specified hierarchy may be simulated.</abstract></paper>