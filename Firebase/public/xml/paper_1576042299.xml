<paper id="1576042299"><title>Reasoning with Executable Specifications</title><year>1995</year><authors><author org="Inria - Sophia Antipolis" id="22202220">Yves Bertot</author><author org="Inria - Sophia Antipolis" id="291354261">Ranan Fraer</author></authors><n_citation>15</n_citation><doc_type>Conference</doc_type><references><reference>183886856</reference><reference>1507396723</reference><reference>1511668635</reference><reference>1519972603</reference><reference>1527862632</reference><reference>1551663574</reference><reference>1556867883</reference><reference>1561822296</reference><reference>1583095677</reference><reference>1583178859</reference><reference>1596425290</reference><reference>1949275316</reference><reference>1974190112</reference><reference>2044553249</reference><reference>2154940799</reference><reference>2547751540</reference><reference>2913158420</reference></references><venue id="2756386172" type="C">Colloquium on trees in Algebra and Programming</venue><doi>10.1007/3-540-59293-8_218</doi><keywords><keyword weight="0.64495">Specification language</keyword><keyword weight="0.478">Programming language</keyword><keyword weight="0.60526">Programming language specification</keyword><keyword weight="0.45705">Computer science</keyword><keyword weight="0.55625">Correctness</keyword><keyword weight="0.57819">Object language</keyword><keyword weight="0.62962">Formal specification</keyword><keyword weight="0.57968">Formal methods</keyword><keyword weight="0.5794">Formal verification</keyword><keyword weight="0.65794">Executable</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Starting from the specification of a small imperative programming language, and the description of two program transformations on this language, we formally prove the correctness of these transformations. The formal specifications are given in a single format, and can be compiled into both executable tools and collections of definitions to reason about into a theorem prover. This work is a case study of an environment integrating executable tool generation and formal reasoning on these tools.</abstract></paper>