<paper id="1593436246"><title>Integrating Scalar Optimization and Parallelization</title><year>1991</year><authors><author org="Stanford, University" id="2620466500">Steven W. K. Tjiang</author><author org="Stanford, University" id="2461088018">Michael E. Wolf</author><author org="Stanford, University" id="2136170053">Monica S. Lam</author><author org="Stanford, University" id="2574486893">K. Pieper</author><author org="Stanford, University" id="1965698830">John L. Hennessy</author></authors><n_citation>30</n_citation><doc_type>Conference</doc_type><references><reference>1491178396</reference><reference>2005014436</reference><reference>2040588708</reference><reference>2064506719</reference><reference>2075055870</reference><reference>2116446217</reference><reference>2119609467</reference><reference>2133820361</reference><reference>2152506070</reference></references><venue id="1198129048" type="C">Languages and Compilers for Parallel Computing</venue><doi>10.1007/BFb0038662</doi><keywords><keyword weight="0.45707">Abstraction</keyword><keyword weight="0.54583">Memory hierarchy</keyword><keyword weight="0.47253">Programming language</keyword><keyword weight="0.0">Loop transformation</keyword><keyword weight="0.45321">Computer science</keyword><keyword weight="0.46836">Parallel computing</keyword><keyword weight="0.46027">Scalar (physics)</keyword><keyword weight="0.4607">Theoretical computer science</keyword><keyword weight="0.63982">Compiler</keyword><keyword weight="0.0">Intermediate language</keyword><keyword weight="0.48973">Binary expression tree</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Compiling programs to use parallelism and memory hierarchy efficiently requires both parallelizing (high-level) transformations and traditional scalar (low-level) optimizations. Our compiler has only one intermediate language — SUIF (Stanford University Intermediate Form) — for both parallelization and scalar optimizations. Having only one intermediate language offers two advantages: no duplication of functions between the two levels, and availability of high-level information at the low-level. This paper shows how SUIF integrates the two levels of abstraction, and how the SUIF compiler is organized to take advantage of this integration.</abstract></paper>