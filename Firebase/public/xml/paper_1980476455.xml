<paper id="1980476455"><title>Representing layered monads</title><year>1999</year><authors><author org="BRICS, Department of Computer Science, University of Aarhus, Ny Munkegade, DK-8000 Aarhus C, Denmark" id="262920028">Andrzej Filinski</author></authors><n_citation>104</n_citation><doc_type>Conference</doc_type><references><reference>1506195600</reference><reference>1523016082</reference><reference>1539369778</reference><reference>1783388813</reference><reference>1870682227</reference><reference>1893810794</reference><reference>1992124283</reference><reference>1995674161</reference><reference>1999336811</reference><reference>1999643018</reference><reference>2002301065</reference><reference>2002529995</reference><reference>2007270285</reference><reference>2032063820</reference><reference>2037984920</reference><reference>2047869411</reference><reference>2060852846</reference><reference>2073904768</reference><reference>2074674709</reference><reference>2078944436</reference><reference>2083697466</reference><reference>2097230120</reference><reference>2141576692</reference><reference>2156876717</reference><reference>2293168108</reference><reference>2294422796</reference><reference>2913378306</reference></references><venue id="1160032607" type="C">Symposium on Principles of Programming Languages</venue><doi>10.1145/292540.292557</doi><keywords><keyword weight="0.46982">Programming language</keyword><keyword weight="0.51308">Subroutine</keyword><keyword weight="0.56162">Concurrency</keyword><keyword weight="0.49995">Delimited continuation</keyword><keyword weight="0.455">Computer science</keyword><keyword weight="0.46267">Theoretical computer science</keyword><keyword weight="0.49121">Thread (computing)</keyword><keyword weight="0.49439">Polymorphic recursion</keyword><keyword weight="0.50722">Bytecode</keyword><keyword weight="0.51516">Semantics</keyword><keyword weight="0.55513">Monad (functional programming)</keyword></keywords><publisher>ACM</publisher><abstract>There has already been considerable research on constructing modular, monad-based specifications of computational effects (state, exceptions, nondeterminism, etc.) in programming languages. We present a simple framework in this tradition, based on a Church-style effect-typing system for an ML-like language. The semantics of this language is formally defined by a series of monadic translations, each one expanding away a layer of effects. Such a layered specification is easy to reason about, but its direct implementation (whether by parameterized interpretation or by actual translation) is often prohibitively inefficient.By exploiting deeper semantic properties of monads, however, it is also possible to derive a vastly more efficient implementation: we show that each layer of effects can be uniformly simulated by continuation-passing, and further that multiple such layers can themselves be simulated by a standard semantics for call/cc and mutable state. Thus, even multi-effect programs can be executed in Scheme or SML/NJ at full native speed, generalizing an earlier single-effect result. As an example, we show how a simple resumption-based semantics of concurrency allows us to directly simulate a shared-state program across all possible dynamic interleavings of execution threads.</abstract></paper>