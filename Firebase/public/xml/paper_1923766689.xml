<paper id="1923766689"><title>Inheritance in Higher Order Logic: Modeling and Reasoning</title><year>2000</year><authors><author org="University of Nijmegen" id="2148094435">Marieke Huisman</author><author org="University of Nijmegen" id="2105127320">Bart Jacobs</author></authors><n_citation>18</n_citation><doc_type>Conference</doc_type><references><reference>1509854283</reference><reference>1527018329</reference><reference>1533109738</reference><reference>1544633123</reference><reference>1544646281</reference><reference>1544933093</reference><reference>1578560741</reference><reference>1644882639</reference><reference>1661076342</reference><reference>2057835515</reference><reference>2074436507</reference><reference>2080549728</reference><reference>2104506944</reference><reference>2113486906</reference><reference>2138839382</reference><reference>2161825580</reference><reference>2170800927</reference><reference>2171058032</reference><reference>2173184982</reference><reference>2583032417</reference></references><venue id="2538859667" type="C">Theorem Proving in Higher Order Logics</venue><doi>10.1007/3-540-44659-1_19</doi><keywords><keyword weight="0.0">Java classes</keyword><keyword weight="0.50934">Late binding</keyword><keyword weight="0.47492">Programming language</keyword><keyword weight="0.55325">Object-oriented programming</keyword><keyword weight="0.45995">Computer science</keyword><keyword weight="0.0">Java program</keyword><keyword weight="0.51246">Type theory</keyword><keyword weight="0.43865">Algorithm</keyword><keyword weight="0.46223">Theoretical computer science</keyword><keyword weight="0.56577">Higher-order logic</keyword><keyword weight="0.48019">Software development</keyword><keyword weight="0.0">Program specification</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>This paper describes a way of modeling inheritance (in object-oriented programming languages) in higher order logic. This particular approach is used in the LOOP project for reasoning about JAVA classes, with the proof tools PVS and ISABELLE. It relies on nested interface types to capture the superclasses, fields, methods, and constructors of classes, together with suitable casting functions incorporating the difference between hiding of fields and overriding of methods. This leads to the proper handling of late binding, as illustrated in several verification examples.</abstract></paper>