<paper id="1590266960"><title>Realizable and Unrealizable Specifications of Reactive Systems</title><year>1989</year><authors><author org="Systems Research Center" id="2162106674">Martín Abadi</author><author org="Systems Research Center" id="2096750770">Leslie Lamport</author><author org="Université de Liège**" id="2120041131">Pierre Wolper</author></authors><n_citation>218</n_citation><doc_type>Conference</doc_type><references><reference>80787065</reference><reference>1579468405</reference><reference>1737156267</reference><reference>1969912861</reference><reference>1970603830</reference><reference>1984478483</reference><reference>2016206563</reference><reference>2031592188</reference><reference>2033071128</reference><reference>2040127143</reference><reference>2048355938</reference><reference>2102097307</reference><reference>2110425399</reference><reference>2124192263</reference><reference>2137865376</reference><reference>2163151383</reference><reference>2169869634</reference><reference>2535076018</reference><reference>2914206182</reference></references><venue id="1141821850" type="C">International Colloquium on Automata, Languages and Programming</venue><doi>10.1007/BFb0035748</doi><keywords><keyword weight="0.52864">Transition system</keyword><keyword weight="0.44219">Programming language</keyword><keyword weight="0.52374">Program synthesis</keyword><keyword weight="0.44409">Computer science</keyword><keyword weight="0.43665">Theoretical computer science</keyword><keyword weight="0.49567">Implementation</keyword><keyword weight="0.50027">Finite-state machine</keyword><keyword weight="0.48812">Temporal logic</keyword><keyword weight="0.48438">Reactive system</keyword><keyword weight="0.51384">Realizability</keyword><keyword weight="0.51986">Liveness</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>A specification is useless if it cannot be realized by any concrete implementation. There are obvious reasons why it might be unrealizable: it might require the computation of a nonrecursive function, or it might be logically inconsistent. A more subtle danger is specifying the behavior of part of the universe outside the implementor’s control. This source of unrealizability is most likely to infect specifications of concurrent systems or reactive systems [HP85]. It is this source of unrealizability that concerns us. Formally, a specification is a set of sequences of states, which represents the set of allowed behaviors of a system. We do not distinguish between specifications and programs; a Pascal program and a temporal logic specification are both specifications, although one is at a lower level than the other. (Some may wonder which is the lower-level one.) A specification S1 is said to implement a specification S2 iff (if and only if) it allows fewer behaviors than S2. We define a class of realizable specifications. It includes all specifications that can be implemented by physically possible systems, but also some that have no real implementations for reasons that do not concern us—for example, because they presume the computation of nonrecursive functions. In general, deciding whether a specification is realizable may be difficult. For a specification that includes only safety properties, determining realizability is easy in principle. A specification is unrealizable iff it constrains the environment. A safety property asserts that something bad does not happen. It constrains the environment iff there is some sequence of states in which the environment makes the bad thing happen. However, for liveness requirements, which assert that something good must eventually happen, it is not easy to determine if they constrain the environment. To study realizability, we consider a specification to be a type of infinite game of perfect information [Mar75], where the system plays against the environment and wins if it produces a correct behavior. Under hypotheses justified</abstract></paper>