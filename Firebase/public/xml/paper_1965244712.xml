<paper id="1965244712"><title>Verification of Fair Transisiton Systems</title><year>1996</year><authors><author org="Bell-Labs" id="312154185">Orna Kupferman</author><author org="Rice University" id="1970575723">Moshe Y. Vardi</author></authors><n_citation>34</n_citation><doc_type>Conference</doc_type><references><reference>1487199072</reference><reference>1503973138</reference><reference>1527753554</reference><reference>1534067655</reference><reference>1557218117</reference><reference>1590283810</reference><reference>1593428110</reference><reference>1753324106</reference><reference>1798280647</reference><reference>1967669950</reference><reference>1975657455</reference><reference>1988808695</reference><reference>1989887898</reference><reference>1990183105</reference><reference>1990609140</reference><reference>1994350081</reference><reference>1994797527</reference><reference>2000302396</reference><reference>2003227046</reference><reference>2007464118</reference><reference>2009965218</reference><reference>2011039300</reference><reference>2031592188</reference><reference>2039853888</reference><reference>2040127143</reference><reference>2043360684</reference><reference>2051621669</reference><reference>2066989651</reference><reference>2075211719</reference><reference>2090398333</reference><reference>2093916942</reference><reference>2098817244</reference><reference>2115698108</reference><reference>2117189826</reference><reference>2132107743</reference><reference>2136920408</reference><reference>2137865376</reference><reference>2162844904</reference></references><venue id="1162450063" type="C">Computer Aided Verification</venue><doi>10.1007/3-540-61474-5_84</doi><keywords><keyword weight="0.55458">Transition system</keyword><keyword weight="0.44734">Abstraction</keyword><keyword weight="0.48052">Computer science</keyword><keyword weight="0.4636">Algorithm</keyword><keyword weight="0.4804">Theoretical computer science</keyword><keyword weight="0.62539">Reference implementation</keyword><keyword weight="0.40497">Embodied cognition</keyword><keyword weight="0.54128">Temporal logic</keyword><keyword weight="0.62756">Computation tree</keyword><keyword weight="0.50761">Computation</keyword></keywords><publisher>Springer-Verlag</publisher><abstract>In program verification, we check that an implementation meets its specification. Both the specification and the implementation describe the possible behaviors of the program, although at different levels of abstraction. We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification. The second approach is tree-based implementation, where we require every computation tree embodied in the implementation to correlate to some computation tree embodied in the specification. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic. In this work, we examine the trace-based and the tree-based approaches from a complexity-theoretic point of view. We consider and compare the complexity of verification of fair transition systems, modeling both the implementation and the specification in the two approaches. We consider unconditional, weak, and strong fairnesses. For the trace-based approach, the corresponding problem is fair containment. For the tree-based approach, the corresponding problem is fair simulation. We show that while both problems are PSPACE-complete, their complexities in terms of the size of the implementation do not coincide, and the trace-based approach is easier. As the implementation is normally much bigger than the specification, we see this as an advantage of the trace-based approach. Our results are at variance with the known results for the case of transition systems with no fairness, where no approach is evidently advantageous.</abstract></paper>