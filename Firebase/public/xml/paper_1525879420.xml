<paper id="1525879420"><title>Realizability and Synthesis of Reactive Modules</title><year>1994</year><authors><author org="Stanford, University" id="79875117">Anuchit Anuchitanukul</author><author org="Stanford, University" id="2146370811">Zohar Manna</author></authors><n_citation>27</n_citation><doc_type>Conference</doc_type><references><reference>1737156267</reference><reference>2012436850</reference><reference>2016206563</reference><reference>2040127143</reference><reference>2048355938</reference><reference>2061841985</reference><reference>2806619258</reference></references><venue id="1162450063" type="C">Computer Aided Verification</venue><doi>10.1007/3-540-58179-0_51</doi><keywords><keyword weight="0.59178">Computation tree logic</keyword><keyword weight="0.56754">Sequential logic</keyword><keyword weight="0.58779">Temporal logic of actions</keyword><keyword weight="0.59582">Interval temporal logic</keyword><keyword weight="0.45632">Computer science</keyword><keyword weight="0.47132">Algorithm</keyword><keyword weight="0.47165">Theoretical computer science</keyword><keyword weight="0.61665">Linear temporal logic</keyword><keyword weight="0.56258">Finite-state machine</keyword><keyword weight="0.5943">Temporal logic</keyword><keyword weight="0.55177">Realizability</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We present two algorithms: a realizability-checking algorithm and a synthesis algorithm. Given a specification of reactive asynchronous modules expressed in prepositional ETL (Extended Temporal Logic), the realizability-checking algorithm decides whether the specification has an actual implementation, under the assumptions of a random environment and fair execution. It also creates a structure which can then be transformed by the synthesis algorithm into a program, represented as a labeled finite automaton. Unlike previous approaches, the realizability-checking algorithm can handle fairness assumptions. The realizability-checking algorithm is incremental and it directly manipulates formulas in linear temporal logic without having to transform into a branching-time logic or other representations.</abstract></paper>