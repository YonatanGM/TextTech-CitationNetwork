<paper id="1511621732"><title>A kernel language for abstract data types and modules.</title><year>1984</year><authors><author org="University of Edinburgh , Edinburgh UK" id="2053967233">R. Burstall</author><author org="Xerox, Palo Alto Research Center, Palo Alto, CA#TAB#" id="2974063933">B. Lampson</author></authors><n_citation>91</n_citation><doc_type>Conference</doc_type><references><reference>326743114</reference><reference>1511997787</reference><reference>1595372275</reference><reference>1756661417</reference><reference>1992520783</reference><reference>2002532745</reference><reference>2099305192</reference><reference>2134112335</reference><reference>2164578007</reference><reference>2166822586</reference></references><venue id="2759279913" type="C">International Symposium on Semantics of Data Types</venue><doi>10.1007/3-540-13346-1_1</doi><keywords><keyword weight="0.6244">Abstract data type</keyword><keyword weight="0.62804">Type system</keyword><keyword weight="0.59339">Operational semantics</keyword><keyword weight="0.4727">Programming language</keyword><keyword weight="0.61441">Simply typed lambda calculus</keyword><keyword weight="0.6366">Typed lambda calculus</keyword><keyword weight="0.45236">Computer science</keyword><keyword weight="0.61147">System F</keyword><keyword weight="0.45911">Theoretical computer science</keyword><keyword weight="0.63938">Generalized algebraic data type</keyword><keyword weight="0.65865">Type constructor</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>A small set of constructs can simulate a wide variety of apparently distinct features in modern programming languages. Using typed lambda calculus with bindings, declarations, and types as first-class values, we show how to build modules, interfaces and implementations, abstract data types, generic types, recursive types, and unions. The language has a concise operational semantics given by inference rules.</abstract></paper>