<paper id="1511610110"><title>Specifying Reusable Components Using Contracts</title><year>1992</year><authors><author org="Northeastern, University" id="2973757926">Ian M. Holland</author></authors><n_citation>115</n_citation><doc_type>Conference</doc_type><references><reference>1595694410</reference><reference>1967918489</reference><reference>1989153383</reference><reference>2007773305</reference><reference>2007798926</reference><reference>2026701237</reference><reference>2033337919</reference><reference>2039574476</reference><reference>2047181711</reference><reference>2072868498</reference><reference>2082340512</reference><reference>2082810026</reference><reference>2086970510</reference><reference>2089060588</reference><reference>2089339698</reference><reference>2128743718</reference><reference>2149185259</reference><reference>2154634413</reference><reference>2158201136</reference></references><venue id="1177184315" type="C">European Conference on Object-Oriented Programming</venue><doi>10.1007/BFb0053043</doi><keywords><keyword weight="0.0">Graph</keyword><keyword weight="0.47977">Programming language</keyword><keyword weight="0.44046">Abstraction</keyword><keyword weight="0.53202">Object-oriented programming</keyword><keyword weight="0.48442">Reuse</keyword><keyword weight="0.4721">Computer science</keyword><keyword weight="0.49135">Depth-first search</keyword><keyword weight="0.47334">Theoretical computer science</keyword><keyword weight="0.53887">Instance variable</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Contracts were introduced by Helm et al. as a high level construct for explicitly specifying interactions among groups of objects. This paper describes further developments and application of the Contract construct. We show how Contracts can be used to represent classic algorithms as large grained reusable object oriented abstractions, how these algorithms can be customized through Contract refinement and how they are reused through Contract conformance. The example algorithm used throughout is the classic graph depth first traversal algorithm. This algorithm is represented as a Contract which is then refined to specify algorithms which number connected regions of graphs and which check graphs for cycles. Changes to the Contract language are introduced and we discuss some new problems resulting from the simultaneous reuse of related contracts.</abstract></paper>