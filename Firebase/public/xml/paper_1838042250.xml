<paper id="1838042250"><title>Deciding bisimulation equivalences for a class of non-finite-state programs</title><year>1989</year><authors><author org="Swedish Institute Of Computer Science" id="2285498729">Bengt Jonsson</author><author org="Swedish Institute Of Computer Science" id="152237314">Joachim Parrow</author></authors><n_citation>2</n_citation><doc_type>Conference</doc_type><references><reference>83847421</reference><reference>1511242199</reference><reference>1997387389</reference><reference>2001280955</reference><reference>2001748564</reference><reference>2012001501</reference><reference>2021473546</reference><reference>2054554282</reference><reference>2057683230</reference><reference>2074674105</reference><reference>2102097307</reference><reference>2137865376</reference><reference>2157144873</reference><reference>2167004912</reference></references><venue id="1178070762" type="C">Symposium on Theoretical Aspects of Computer Science</venue><doi>10.1007/BFb0029004</doi><keywords><keyword weight="0.44452">Discrete mathematics</keyword><keyword weight="0.46261">Programming language</keyword><keyword weight="0.45809">Computer science</keyword><keyword weight="0.0">Finite state</keyword><keyword weight="0.60019">Equivalence (measure theory)</keyword><keyword weight="0.58896">Bisimulation</keyword><keyword weight="0.43025">Computation</keyword><keyword weight="0.47897">Communications protocol</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>Traditionally, many automatic program verification techniques are applicable only to finite-state programs. In this paper we show how to extend some verification techniques to infinite-state programs that may read, store, and write data but not perform any other computations. We present algorithms for deciding strong equivalence and observation equivalence, defined by bisimulations (as in CCS), between such programs. These algorithms have major applications in verification of communication protocols. The equivalence problems are shown to be NP-hard in the size of the programs.</abstract></paper>