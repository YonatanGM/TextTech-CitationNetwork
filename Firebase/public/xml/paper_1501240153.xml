<paper id="1501240153"><title>Checking the Correctness of Architectural Transformation Steps via Proof-Carrying Architectures</title><year>1999</year><authors><author org="SRI, International#TAB#" id="2973774449">R. A. Riemenschneider</author></authors><n_citation>10</n_citation><doc_type>Conference</doc_type><references><reference>1515636722</reference><reference>1534850143</reference><reference>1989623274</reference><reference>2018108160</reference><reference>2051632385</reference><reference>2074236561</reference><reference>2096973649</reference><reference>2105505307</reference><reference>2115603783</reference><reference>2126475077</reference><reference>2142437106</reference><reference>2146082668</reference><reference>2532691812</reference></references><venue id="1130478978" type="C">IEEE/IFIP International Conference on Software Architecture</venue><doi>10.1007/978-0-387-35563-4_5</doi><keywords><keyword weight="0.48297">Architecture</keyword><keyword weight="0.4787">Programming language</keyword><keyword weight="0.46181">Abstraction</keyword><keyword weight="0.47453">Computer science</keyword><keyword weight="0.63343">Correctness</keyword><keyword weight="0.46944">Theoretical computer science</keyword><keyword weight="0.46954">Implementation</keyword><keyword weight="0.47592">Hierarchy</keyword></keywords><publisher>Kluwer, B.V.</publisher><abstract>The end product of architecting is an architectural hierarchy, a collection of architectural descriptions linked by mappings that interpret the more abstract descriptions in the more concrete descriptions. Formalized transformational approaches to architecture refinement and abstraction have been proposed. One argument in favor of formalization is that it can result in architectural implementations that are guaranteed to be correct, relative to the abstract descriptions. If these are correct with respect to one another, conclusions obtained by reasoning from an abstract architectural description will also apply to the implemented architecture. But this correctness guarantee is achieved by requiring that the implementer use only verified transformations, i.e., ones that have been proven to produce correct results when applied. This paper explores an approach that allows the implementer to use transformations that have not been proven to be generally correct, without voiding the correctness guarantee. Checking means determining that application of the transformation produces the desired result. It allows the use of transformations that have not been generally verified, even ones that are known to sometimes produce incorrect results, by showing that they work in the particular case.</abstract></paper>