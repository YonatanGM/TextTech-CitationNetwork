<paper id="1543471126"><title>An Efficient Inclusion-Based Points-To Analysis for Strictly-Typed Languages</title><year>2002</year><authors><author org="Stanford, University" id="2262305730">John Whaley</author><author org="Stanford, University" id="2136170053">Monica S. Lam</author></authors><n_citation>84</n_citation><doc_type>Conference</doc_type><references><reference>1974608873</reference><reference>2044354349</reference><reference>2051600169</reference><reference>2065088439</reference><reference>2069476565</reference><reference>2084816051</reference><reference>2113238444</reference><reference>2131135493</reference><reference>2171240827</reference></references><venue id="1137552346" type="C">Static Analysis Symposium</venue><doi>10.1007/3-540-45789-5_15</doi><keywords><keyword weight="0.47613">Programming language</keyword><keyword weight="0.53868">Object-oriented programming</keyword><keyword weight="0.47477">Computer science</keyword><keyword weight="0.52613">Sparse approximation</keyword><keyword weight="0.51739">Control flow</keyword><keyword weight="0.55606">Dynamic dispatch</keyword><keyword weight="0.48021">Theoretical computer science</keyword><keyword weight="0.54656">Call graph</keyword><keyword weight="0.52076">Memory management</keyword><keyword weight="0.51546">Java</keyword><keyword weight="0.53534">Local variable</keyword><keyword weight="0.46838">Distributed computing</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We describe the design and implementation of an efficient inclusion-based points-to analysis for strictly-typed object-oriented languages. Our implementation easily scales to millions of lines of Java code, and it supports language features suchas inheritance, object fields, exceptional control flow, type casting, dynamic dispatch, and reflection. Our algorithm is based on Heintze and Tardieuu0027s Andersen-style pointsto analysis designed originally for C programs. We have improved the precision of their algorithm by tracking the fields of individual objects separately and by analyzing the local variables in a method in a flow-sensitive manner. Our algorithm represents the semantics of each procedure concisely using a sparse summary graphrepresen tation based on access paths; it iterates over this sparse representation until it reaches a fixed point solution. By utilizing the access path and field information present in the summary graphs, along with minimizing redundant operations and memory management overheads, we are able to quickly and effectively analyze very large programs. Our experimental results demonstrate that this technique can be used to compute precise static call graphs for very large Java programs.</abstract></paper>