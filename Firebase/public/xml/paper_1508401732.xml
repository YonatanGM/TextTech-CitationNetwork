<paper id="1508401732"><title>Formal Reasoning about Hardware and Software Memory Models</title><year>2002</year><authors><author org="National University of Singapore" id="2153766775">Abhik Roychoudhury</author></authors><n_citation>5</n_citation><doc_type>Conference</doc_type><references><reference>1548312885</reference><reference>1644882639</reference><reference>1850405760</reference><reference>2011429153</reference><reference>2029601347</reference><reference>2054739713</reference><reference>2092002125</reference><reference>2117189826</reference><reference>2121217300</reference><reference>2153075575</reference><reference>2164288303</reference><reference>2170389900</reference></references><venue id="1133365479" type="C">International Conference on Formal Engineering Methods</venue><doi>10.1007/3-540-36103-0_44</doi><keywords><keyword weight="0.47416">Programming language</keyword><keyword weight="0.62829">Shared memory</keyword><keyword weight="0.46011">Computer science</keyword><keyword weight="0.46849">Parallel computing</keyword><keyword weight="0.62172">Distributed memory</keyword><keyword weight="0.52558">Formal specification</keyword><keyword weight="0.63685">Memory model</keyword><keyword weight="0.4505">Computer hardware</keyword><keyword weight="0.55665">Overlay</keyword><keyword weight="0.53453">Java</keyword><keyword weight="0.60005">Memory architecture</keyword><keyword weight="0.52565">Executable</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>The Java programming language allows multithreaded programming, where threads can be run on multiprocessor or uniprocessor platforms. The allowed behaviors of any multithreaded Java program on any implementation platform (multi- or uni-processor), are described in terms of a memory consistency model called the Java Memory Model (JMM). However, shared memory multiprocessors have a memory model of their own. To reason about the behavior of multithreaded Java programs on multiprocessors, we need a formal basis for understanding both the hardware memory model (of the multiprocessor platform) and the software memory model (the JMM). For this purpose, we have implemented formal executable specifications of the JMM and certain hardware memory models (such as TSO/PSO from SPARC). These executable specifications can be used for exhaustive search i.e. computing all allowed behaviors of test programs under the JMM and the hardware memory models. Consequently, we can compare the JMM with the hardware memory models (in terms of allowed behaviors). We show that such a comparison can help efficient and reliable multithreaded programming on multiprocessors. Results from comparing the current JMM with SPARC architecture memory models are presented.</abstract></paper>