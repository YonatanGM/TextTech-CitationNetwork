<paper id="1582456956"><title>Analyzing Memory Accesses in x86 Executables</title><year>2004</year><authors><author org="University of Wisconsin" id="2107215626">Gogul Balakrishnan</author><author org="University of Wisconsin" id="341386833">Thomas W. Reps</author></authors><n_citation>297</n_citation><doc_type>Conference</doc_type><references><reference>1496712790</reference><reference>1502028089</reference><reference>1507654557</reference><reference>1510011212</reference><reference>1952910495</reference><reference>1998285060</reference><reference>2004633100</reference><reference>2029068974</reference><reference>2038053930</reference><reference>2040183246</reference><reference>2043100293</reference><reference>2097699872</reference><reference>2107742417</reference><reference>2112481005</reference><reference>2122049982</reference><reference>2127859789</reference><reference>2132661148</reference><reference>2142840915</reference><reference>2158218093</reference><reference>2160255280</reference><reference>2171834078</reference><reference>2770491639</reference></references><venue id="1162239172" type="C">Compiler Construction</venue><doi>10.1007/978-3-540-24723-4_2</doi><keywords><keyword weight="0.47759">x86</keyword><keyword weight="0.46098">Programming language</keyword><keyword weight="0.45348">Computer science</keyword><keyword weight="0.45611">Static analysis</keyword><keyword weight="0.49786">Computer virus</keyword><keyword weight="0.50329">High-level programming language</keyword><keyword weight="0.47374">Plug-in</keyword><keyword weight="0.54293">Memory address</keyword><keyword weight="0.56363">Executable</keyword><keyword weight="0.55466">Debugging</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>This paper concerns static-analysis algorithms for analyzing x86 executables. The aim of the work is to recover intermediate representations that are similar to those that can be created for a program written in a high-level language. Our goal is to perform this task for programs such as plugins, mobile code, worms, and virus-infected code. For such programs, symbol-table and debugging information is either entirely absent, or cannot be relied upon if present; hence, the technique described in the paper makes no use of symbol-table/debugging information. Instead, an analysis is carried out to recover information about the contents of memory locations and how they are manipulated by the executable.</abstract></paper>