<paper id="1531011076"><title>Flexible and Optimized IDL Compilation for Distributed Applications</title><year>1998</year><authors><author org="University of Utah ," id="2089674887">Eric Eide</author><author org="University of Utah ," id="156243902">Jay Lepreau</author><author org="University of Utah ," id="2058789089">James L. Simister</author></authors><n_citation>6</n_citation><doc_type>Journal</doc_type><references><reference>19830081</reference><reference>1556689684</reference><reference>1659340666</reference><reference>1791522999</reference><reference>2001376924</reference><reference>2012643955</reference><reference>2015785281</reference><reference>2087884088</reference><reference>2098111776</reference><reference>2098815550</reference><reference>2115696550</reference><reference>2122960384</reference><reference>2125606443</reference><reference>2128883551</reference><reference>2141253292</reference><reference>2143120180</reference><reference>2155066383</reference><reference>2164719334</reference></references><venue id="106296714" type="J">Lecture Notes in Computer Science</venue><doi>10.1007/3-540-49530-4_21</doi><keywords><keyword weight="0.51935">Middleware</keyword><keyword weight="0.63077">Dead code elimination</keyword><keyword weight="0.53694">Remote procedure call</keyword><keyword weight="0.61096">Code bloat</keyword><keyword weight="0.47081">Programming language</keyword><keyword weight="0.46339">Computer science</keyword><keyword weight="0.61177">Compiler</keyword><keyword weight="0.60835">Optimizing compiler</keyword><keyword weight="0.51714">Active message</keyword><keyword weight="0.46941">Operating system</keyword><keyword weight="0.53658">Message passing</keyword><keyword weight="0.46669">Distributed computing</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>The author of a distributed system is often faced with a dilemma when writing the systemu0027s communication code. If the code is written by hand (e.g., using Active Messages) or partly by hand (e.g., using mpi) then the speed of the application may be maximized, but the human effort required to implement and maintain the system is greatly increased. On the other hand, if the code is generated using a high-level tool (e.g., a corba idl compiler) then programmer effort will be reduced, but the performance of the application may be intolerably poor. The tradeoff between system performance and development effort arises because existing communication middleware is inefficient, imposes excessive presentation layer overhead, and therefore fails to expose much of the underlying network performance to application code. Moreover, there is often a mismatch between the desired communication style of the application (e.g., asynchronous message passing) and the communication style of the code produced by an idl compiler (synchronous remote procedure call). We believe that this need not be the case, but that established optimizing compiler technology can be applied and extended to attack these domain-specific :[185],"have implemented Flick, a flexible and optimizing idl compiler, and are using it to explore techniques for producing high-performance code for distributed and parallel applications. Flick produces optimized code for marshaling and unmarshaling data; experiments show that Flick-generated stubs can marshal data between 2 and 17 times as fast as stubs produced by other idl compilers. Further, because Flick is implemented as a "kit" of components, it is possible to extend the compiler to produce stylized code for many different application interfaces and underlying transport layers. In this paper we outline a novel approach for producing "decomposed" stubs for a distributed global memory service.</abstract></paper>