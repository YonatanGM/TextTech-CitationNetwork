<paper id="1941166084"><title>Recovery of jump table case statements from binary code</title><year>1999</year><authors><author org="Dept. of Comput. Sci. &amp; Electr. Eng., Queensland Univ., Brisbane, Qld., Australia#TAB#" id="2421780944">C. Cifuentes</author><author org="(University of Queensland)" id="2575378903">M. Van Emmerik</author></authors><n_citation>66</n_citation><doc_type>Conference</doc_type><references><reference>195955250</reference><reference>1507654557</reference><reference>1541457918</reference><reference>1993954991</reference><reference>2002633610</reference><reference>2019747336</reference><reference>2031487553</reference><reference>2040183246</reference><reference>2042816544</reference><reference>2060151570</reference><reference>2069652163</reference><reference>2073882597</reference><reference>2104274479</reference><reference>2116424612</reference><reference>2127859789</reference><reference>2134312016</reference><reference>2163935347</reference><reference>2339669378</reference></references><venue id="2622385070" type="C">Workshop on Program Comprehension</venue><doi>10.1109/WPC.1999.777758</doi><keywords><keyword weight="0.60492">Threaded code</keyword><keyword weight="0.60914">Linear code sequence and jump</keyword><keyword weight="0.55255">Code segment</keyword><keyword weight="0.43069">Computer science</keyword><keyword weight="0.53272">Binary code</keyword><keyword weight="0.53916">Assembly language</keyword><keyword weight="0.54866">Compiler</keyword><keyword weight="0.43667">Theoretical computer science</keyword><keyword weight="0.64575">Branch table</keyword><keyword weight="0.54349">Executable</keyword></keywords><publisher>IEEE Computer Society</publisher><abstract>One of the fundamental problems with the analysis of binary (executable) code is that of recognizing, in a machine-independent way, the target addresses of n-conditional branches implemented via a jump table. Without these addresses, the decoding of the machine instructions for a given procedure is incomplete, as well as any analysis on that procedure. We present a technique for recovering jump tables and their target addresses in a machine and compiler independent way. The technique is based on slicing and expression substitution. The assembly code of a procedure that contains an indexed jump is transformed into a normal form which allows us to determine where the jump table is located and what information it contains (e.g. offsets from the table or absolute addresses). The technique has been tested on SPARC and Pentium code generated by C, C++, Fortran and Pascal compilers. Our tests show that up to 90% more of the code in a text segment can be found by using this technique.</abstract></paper>