<paper id="1819824216"><title>One-Time Programs</title><year>2008</year><authors><author org="Weizmann Institute of Science, Rehovot, Israel and MIT, Cambridge, USA#TAB#" id="1728759264">Shafi Goldwasser</author><author org="Georgia Tech., Atlanta, USA#TAB#" id="64276155">Yael Tauman Kalai</author><author org="MIT, Cambridge , USA" id="1096017270">Guy N. Rothblum</author></authors><n_citation>183</n_citation><doc_type>Patent</doc_type><references><reference>30575285</reference><reference>103647506</reference><reference>111085860</reference><reference>236432643</reference><reference>1492842426</reference><reference>1495266644</reference><reference>1508362310</reference><reference>1538463291</reference><reference>1542455165</reference><reference>1553849618</reference><reference>1559498407</reference><reference>1592625985</reference><reference>1596808060</reference><reference>1601001795</reference><reference>1663689473</reference><reference>1970606468</reference><reference>1987667503</reference><reference>1988374166</reference><reference>1996888795</reference><reference>1999900367</reference><reference>2010553858</reference><reference>2011112377</reference><reference>2026219353</reference><reference>2084641398</reference><reference>2097651164</reference><reference>2097724213</reference><reference>2119422255</reference><reference>2132779253</reference><reference>2186373936</reference><reference>2770138953</reference></references><venue id="1153524033" type="C">International Cryptology Conference</venue><doi>10.1007/978-3-540-85174-5_3</doi><keywords><keyword weight="0.4989">Black box (phreaking)</keyword><keyword weight="0.46054">Programming language</keyword><keyword weight="0.46723">Computer science</keyword><keyword weight="0.50169">Cryptography</keyword><keyword weight="0.45727">Theoretical computer science</keyword><keyword weight="0.47969">Software</keyword><keyword weight="0.49301">Mathematical proof</keyword><keyword weight="0.50616">Turing machine</keyword><keyword weight="0.51483">Obfuscation</keyword><keyword weight="0.52144">Security token</keyword><keyword weight="0.50652">Oblivious transfer</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>In this work, we introduce one-time programs, a new computational paradigm geared towards security applications. A one-time program can be executed on a singleinput, whose value can be specified at run time. Other than the result of the computation on this input, nothing else about the program is leaked. Hence, a one-time program is like a black box function that may be evaluated once and then "self destructs." This also extends to k-time programs, which are like black box functions that can be evaluated ktimes and then self :[88],"programs serve many of the same purposes of program obfuscation, the obvious one being software protection, but also including applications such as temporary transfer of cryptographic ability. Moreover, the applications of one-time :[88],"programs go well beyond those of obfuscation, since one-time :[88],"programs can only be executed once (or more generally, a limited number of times) while obfuscated :[88],"programs have no such bounds. For example, one-time :[88],"programs lead naturally to electronic cash or token schemes: coins are generated by a program that can only be run once, and thus cannot be double :[180],"significantly, the new paradigm of one-time computing opens new avenues for conceptual research. In this work we explore one such avenue, presenting the new concept of "one-time proofs," proofs that can only be verified once and then become useless and :[221],"these tasks are clearly impossible using software alone, as any piece of software can be copied and run again, enabling the user to execute the program on more than one input. All our solutions employ a secure memory device, inspired by the cryptographic notion of interactive oblivious transfer protocols, that stores two secret keys (k 0 ,k 1 ). The device takes as input a single bit biÂ¾? {0,1}, outputs k b , and then self destructs. Using such devices, we demonstrate that for every input length, any standard program (Turing machine) can be efficiently compiled into a functionally equivalent one-time program. We also show how this memory device can be used to construct one-time proofs. Specifically, we show how to use this device to efficiently convert a classical witness for any NPstatement, into "one-time proof" for that statement.</abstract></paper>