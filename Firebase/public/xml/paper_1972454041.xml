<paper id="1972454041"><title>Problem solving techniques for the design of algorithms</title><year>1984</year><authors><author org="Department of Computer Science, Carnegie-Mellon University, Pittsburgh, PA 15213, U.S.A." id="2013396660">Elaine Kant</author><author org="Department of Computer Science, Carnegie-Mellon University, Pittsburgh, PA 15213, U.S.A." id="2126658068">Allen Newell</author></authors><n_citation>98</n_citation><doc_type>Journal</doc_type><references><reference>91152120</reference><reference>101861336</reference><reference>159774411</reference><reference>1483471644</reference><reference>1501447882</reference><reference>1510293570</reference><reference>1594275893</reference><reference>1604647650</reference><reference>1998954792</reference><reference>2013373314</reference><reference>2068571651</reference><reference>2094837773</reference><reference>2098780004</reference></references><venue id="174847851" type="J">Information Processing and Management</venue><doi>10.1016/0306-4573(84)90042-6</doi><keywords><keyword weight="0.64866">Algorithmics</keyword><keyword weight="0.57103">Algorithm design</keyword><keyword weight="0.54765">Convex hull algorithms</keyword><keyword weight="0.47735">Computer science</keyword><keyword weight="0.60019">K-server problem</keyword><keyword weight="0.47132">Algorithm</keyword><keyword weight="0.61473">Probabilistic analysis of algorithms</keyword><keyword weight="0.48304">Theoretical computer science</keyword><keyword weight="0.48486">Operator (computer programming)</keyword><keyword weight="0.52697">Symbolic execution</keyword><keyword weight="0.58466">Divide and conquer algorithms</keyword></keywords><publisher>Pergamon</publisher><abstract>Abstract By studying the problem-solving techniques that people use to design algorithms we can learn something about building systems that automatically derive algorithms or assist human designers. In this paper we present a model of algorithm design based on our analysis of the protocols of two subjects designing three convex hull algorithms. The subjects work mainly in a data-flow problem space in which the objects are representations of partially specified algorithms. A small number of general-purpose operators construct and modify the representations; these operators are adapted to the current problem state by means-ends analysis. The problem space also includes knowledge-rich schemas such as divide and conquer that subjects incorporate into their algorithms. A particularly versatile problem-solving method in this problem space is symbolic execution, which can be used to refine, verify, or explain components of an algorithm. The subjects also work in a task-domain space about geometry. The interplay between problem solving in the two spaces makes possible the process of discovery. We have observed that the time a subject takes to design an algorithm is proportional to the number of components in the algorithmu0027s data-flow representation. Finally, the details of the problem spaces provide a model for building a robust automated system.</abstract></paper>