<paper id="1970854199"><title>Improving the cache locality of memory allocation</title><year>1993</year><authors><author org="" id="2310158707">Dirk Grunwald</author><author org="" id="2406631840">Benjamin Zorn</author><author org="" id="2638188933">Robert Henderson</author></authors><n_citation>79</n_citation><doc_type>Conference</doc_type><references><reference>1564994301</reference><reference>2016909415</reference><reference>2028080565</reference><reference>2039222964</reference><reference>2055957613</reference><reference>2058693334</reference><reference>2061511578</reference><reference>2061995249</reference><reference>2081626749</reference><reference>2085325584</reference><reference>2091933514</reference><reference>2113440470</reference><reference>2127007340</reference><reference>2143285027</reference><reference>2158364508</reference><reference>2167807594</reference><reference>2295099251</reference></references><venue id="1127352206" type="C">Programming Language Design and Implementation</venue><doi>10.1145/155090.155107</doi><keywords><keyword weight="0.60411">Interleaved memory</keyword><keyword weight="0.74393">Locality of reference</keyword><keyword weight="0.44138">Computer science</keyword><keyword weight="0.60674">Cache</keyword><keyword weight="0.44332">Parallel computing</keyword><keyword weight="0.4331">Real-time computing</keyword><keyword weight="0.6101">Thrashing</keyword><keyword weight="0.58588">Memory management</keyword><keyword weight="0.62708">Cache coloring</keyword><keyword weight="0.60714">Non-uniform memory access</keyword><keyword weight="0.62993">Allocator</keyword></keywords><publisher>ACM</publisher><abstract>The allocation and disposal of memory is a ubiquitous operation in most programs. Rarely do programmers concern themselves with details of memory allocators; most assume that memory allocators provided by the system perform well. This paper presents a performance evaluation of the reference locality of dynamic storage allocation algorithms based on trace-driven simualtion of five large allocation-intensive C programs. In this paper, we show how the design of a memory allocator can significantly affect the reference locality for various applications. Our measurements show that poor locality in sequential-fit allocation algorithms reduces program performance, both by increasing paging and cache miss rates. While increased paging can be debilitating on any architecture, cache misses rates are also important for modern computer architectures. We show that algorithms attempting to be space-efficient by coalescing adjacent free objects show poor reference locality, possibly negating the benefits of space efficiency. At the other extreme, algorithms can expend considerable effort to increase reference locality yet gain little in total execution performance. Our measurements suggest an allocator design that is both very fast and has good locality of reference.</abstract></paper>