<paper id="1579170619"><title>Automatic online partial evaluation</title><year>1991</year><authors><author org="Stanford, University" id="2204613330">Daniel Weise</author><author org="Stanford, University" id="2285760804">Roland Conybeare</author><author org="Stanford, University" id="2984892714">Erik Ruf</author><author org="Stanford, University" id="2171693580">Scott Seligman</author></authors><n_citation>64</n_citation><doc_type>Conference</doc_type><references><reference>43388310</reference><reference>1493363766</reference><reference>1566968514</reference><reference>1607247974</reference><reference>1987632834</reference><reference>1996081324</reference><reference>2003411722</reference><reference>2020024606</reference><reference>2023299380</reference><reference>2070047551</reference><reference>2084099544</reference><reference>2090036644</reference><reference>2091465888</reference><reference>2093264024</reference><reference>2095460218</reference><reference>2104577699</reference><reference>2121569569</reference></references><venue id="1162793720" type="C">International Conference on Functional Programming</venue><doi>10.1007/3540543961_9</doi><keywords><keyword weight="0.52729">Specification language</keyword><keyword weight="0.50754">Fifth-generation programming language</keyword><keyword weight="0.4722">Programming language</keyword><keyword weight="0.521">Programming language specification</keyword><keyword weight="0.5377">Functional programming</keyword><keyword weight="0.53462">Partial evaluation</keyword><keyword weight="0.46584">Computer science</keyword><keyword weight="0.4705">Theoretical computer science</keyword><keyword weight="0.53041">High-level programming language</keyword><keyword weight="0.53764">Symbolic execution</keyword><keyword weight="0.5181">Programming language implementation</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>We have solved the problem of constructing a fully automatic online program specializer for an untyped functional language (specifically, the functional subset of Scheme). We designed our specializer, called Fuse, as an interpreter that returns a trace of suspended computations. The trace is represented as a graph, rather than as program text, and each suspended computation indicates the type of its result. A separate process translates the graph into a particular programming language. Producing graphs rather than program text solves problems with code duplication and premature reduce/residualize decisions. Fuseu0027s termination strategy, which employs online generalization, specializes conditional recursive function calls, and unfolds all other calls. This strategy is shown to be both powerful and safe.</abstract></paper>