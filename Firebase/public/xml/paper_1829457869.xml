<paper id="1829457869"><title>Ensuring Streams Flow</title><year>1997</year><authors><author org="The Computing Laboratory, The University, Canterbury, UK" id="2012647021">Alastair Telford</author><author org="The Computing Laboratory, The University, Canterbury, UK" id="2606732502">David Turner</author></authors><n_citation>31</n_citation><doc_type>Conference</doc_type><references><reference>1484366641</reference><reference>1491165055</reference><reference>1541318173</reference><reference>1759945398</reference><reference>1807713620</reference><reference>1980786790</reference><reference>1985853644</reference><reference>2049641148</reference><reference>2103953153</reference><reference>2107474854</reference><reference>2124318699</reference><reference>2137865376</reference><reference>2151384546</reference><reference>2166822586</reference><reference>2180914204</reference><reference>2613512071</reference><reference>2912541449</reference></references><venue id="1191172908" type="C">Algebraic Methodology and Software Technology</venue><doi>10.1007/BFb0000493</doi><keywords><keyword weight="0.48062">Data structure</keyword><keyword weight="0.44502">Programming language</keyword><keyword weight="0.51309">Functional programming</keyword><keyword weight="0.44191">Computer science</keyword><keyword weight="0.49063">Abstract interpretation</keyword><keyword weight="0.51324">Type theory</keyword><keyword weight="0.44466">Theoretical computer science</keyword><keyword weight="0.53296">Coinduction</keyword><keyword weight="0.46725">Parsing</keyword><keyword weight="0.46384">Syntax</keyword><keyword weight="0.47781">Computer programming</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>It is our aim to develop an elementary strong functional programming (ESFP) system. To be useful, ESFP should include structures such as streams which can be computationally unwound infinitely often. We describe a syntactic analysis to ensure that infinitely proceeding structures, which we shall term codata, are productive. This analysis is an extension of the check for guardedness that has been used with definitions over coinductive types in Martin-Lofu0027s type theory and in the calculus of constructions. Our analysis is presented as a form of abstract interpretation that allows a wider syntactic class of corecursive definitions to be recognised as productive than in previous work. Thus programmers will have fewer restrictions on their use of infinite streams within a strongly normalizing functional language.</abstract></paper>