<paper id="1549180787"><title>On the complexity of finding short vectors in integer lattices</title><year>1983</year><authors><author org="University of Toronto,#TAB#" id="1971168030">Erich Kaltofen</author></authors><n_citation>37</n_citation><doc_type>Conference</doc_type><references><reference>1991224576</reference><reference>2083368929</reference><reference>2114616381</reference><reference>2142775997</reference></references><venue id="2756322194" type="C">European Conference on Computer Algebra</venue><doi>10.1007/3-540-12868-9_107</doi><keywords><keyword weight="0.55371">Integer</keyword><keyword weight="0.0">Integer multiplication</keyword><keyword weight="0.47386">Discrete mathematics</keyword><keyword weight="0.58686">Linear independence</keyword><keyword weight="0.47429">Combinatorics</keyword><keyword weight="0.47865">Lattice (order)</keyword><keyword weight="0.51733">Euclidean distance</keyword><keyword weight="0.65336">Integer lattice</keyword><keyword weight="0.54633">Basis (linear algebra)</keyword><keyword weight="0.42167">Mathematics</keyword><keyword weight="0.49906">Binary number</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>In [Lenstra, A., et al. 82] an algorithm is presented which, given n linearly independent n-dimensional integer vectors, calculates a vector in the integer lattice spanned by these vectors whose Euclidean length is within a factor of 2(nâˆ’1)/2 of the length of the shortest vector in this lattice. If B denotes the maximum length of the basis vectors, the algorithm is shown to run in O(n6(log B)3) binary steps. We prove that this algorithm can actually be executed in O(n6(log B)2+n5(log B)3) binary steps by analyzing a modified version of the algorithm which also performs better in practice.</abstract></paper>