<paper id="1495686243"><title>Architecture Software Using: A Methodology for Language Development</title><year>1998</year><authors><author org="University of Rennes" id="171983298">Charles Consel</author><author org="University of Rennes" id="687420851">Renaud Marlet</author></authors><n_citation>30</n_citation><doc_type>Journal</doc_type><references><reference>15799706</reference><reference>170403769</reference><reference>1485300234</reference><reference>1556604985</reference><reference>1707936708</reference><reference>1797198873</reference><reference>1844479717</reference><reference>1995674161</reference><reference>2019722731</reference><reference>2021981721</reference><reference>2037984920</reference><reference>2046631444</reference><reference>2058958439</reference><reference>2059237359</reference><reference>2075253235</reference><reference>2077436409</reference><reference>2084099544</reference><reference>2095587790</reference><reference>2100020698</reference><reference>2110753312</reference><reference>2116844130</reference><reference>2141576692</reference><reference>2149146154</reference><reference>2164057873</reference><reference>2168348603</reference></references><venue id="106296714" type="J">Lecture Notes in Computer Science</venue><doi>10.1007/BFb0056614</doi><keywords><keyword weight="0.51201">Program transformation</keyword><keyword weight="0.45085">Programming language</keyword><keyword weight="0.47535">Software design description</keyword><keyword weight="0.43444">Computer science</keyword><keyword weight="0.48794">Partial evaluation</keyword><keyword weight="0.48581">Unix</keyword><keyword weight="0.49775">Compiler</keyword><keyword weight="0.51827">Input/output</keyword><keyword weight="0.47584">Interpreter</keyword><keyword weight="0.52297">Abstract machine</keyword></keywords><publisher>Springer, Berlin, Heidelberg</publisher><abstract>I m p l e m e n t a t i o n . The abstract machine is then given an implementation (typ- ically, a library), or possibly many, to account for different operational con- texts. The valuation function can be implemented as an interpreter based on an abstract machine implementation, or as a compiler to abstract machine instructions. P a r t i a l e v a l u a t i o n . While interpreting is more flexible, compiling is more effi- cient. To get the best of both worlds, we use a program transformation tech- nique, namely, partial evaluation, to automatically transform a DSL program into a compiled program, given only an interpreter. Each of the above methodology steps is further detailed in a separate section of this paper. 1.6 A W o r k i n g E x a m p l e To illustrate our approach, an example of DSL is used throughout the paper. We introduce a simple electronic mail processing application as a working example. Conceptually this application enables users to specify automatic treatments of incoming messages depending on their nature and contents: dispatching mes- sages to people or folders, filtering spam, offering a shell escape (e.g., to feed an electronic agenda), replying to messages when absent, etc. This example is inspired by a Unix program called s l o c a l which offers users a way of processing inbound mail. With s l o c a l , user-defined treatments are expressed in the form of rules. Each rule consists of a string to be searched in a message field (e.g., Subjec t , From) and an action to be performed if the string</abstract></paper>