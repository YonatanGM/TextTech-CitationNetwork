<paper id="1963658586"><title>The categorical abstract machine</title><year>1987</year><authors><author org="Univ. Paris, Paris Cedex, France#TAB#" id="2251403621">G. Cousineau</author><author org="Univ. Paris, Paris Cedex, France#TAB#" id="2020154163">P.-L. Curien</author></authors><n_citation>208</n_citation><doc_type>Journal</doc_type><references><reference>1523047387</reference><reference>1525140360</reference><reference>1527809250</reference><reference>1547379247</reference><reference>2003342148</reference><reference>2010152469</reference><reference>2026557621</reference><reference>2047323187</reference><reference>2063068243</reference><reference>2088735483</reference><reference>2113757735</reference></references><venue id="21029587" type="J">Science of Computer Programming</venue><doi>10.1016/0167-6423(87)90020-7</doi><keywords><keyword weight="0.65274">Categorical logic</keyword><keyword weight="0.55538">Lambda calculus</keyword><keyword weight="0.47231">Programming language</keyword><keyword weight="0.58511">Categorical variable</keyword><keyword weight="0.46044">Computer science</keyword><keyword weight="0.57882">Combinatory logic</keyword><keyword weight="0.54223">Lazy evaluation</keyword><keyword weight="0.58213">SECD machine</keyword><keyword weight="0.46811">Theoretical computer science</keyword><keyword weight="0.69589">Categorical abstract machine</keyword><keyword weight="0.56175">Abstract machine</keyword></keywords><publisher>Elsevier North-Holland, Inc.</publisher><abstract>The Cartesian closed categories have been shown by several authors to provide the right framework of the model theory of λ-calculus. The second author developed this as a syntactic equivalence between two calculi, giving rise to a new kind of combinatory logic: the categorical combinatory logic, where computations can be done through simple rewrite rules, and, as usual with combinators, avoiding problems with variable name clashes. This paper goes further (though not requiring a previous knowledge of categorical combinatory logic) and describes a very simple machine where categorical terms can be considered as code acting on a graph of values. The only saving mechanism is a stack containing pointers on code or on the graph. Abstractions are handled using closures. The machine is called categorical abstract machine or CAM. The CAM is easier to grasp and prove than the SECD machine. The natural evaluation strategy in the CAM is call-by-value, but lazy evaluation can be easily incorporated. The paper discusses the implementation of a real functional programming language, ML, through the CAM. A basic acquaintance with λ-calculus is required.</abstract></paper>