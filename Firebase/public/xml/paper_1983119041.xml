<paper id="1983119041"><title>Quickly detecting relevant program invariants</title><year>2000</year><authors><author org="Dept. of Computer Science &amp; Engineering, University of Washington, Box 352350, Seattle WA" id="2235702021">Michael D. Ernst</author><author org="Dept. of Computer Science &amp; Engineering, University of Washington, Box 352350, Seattle WA" id="2404043386">Adam Czeisler</author><author org="Dept. of Computer Science &amp; Engineering, University of California San Diego, 0114, La Jolla, CA" id="2112220066">William G. Griswold</author><author org="Dept. of Computer Science &amp; Engineering, University of Washington, Box 352350, Seattle WA" id="477007165">David Notkin</author></authors><n_citation>217</n_citation><doc_type>Conference</doc_type><references><reference>2103318645</reference><reference>2134691366</reference><reference>2147543351</reference><reference>2150580621</reference><reference>2163319971</reference><reference>2165026393</reference><reference>2171242934</reference></references><venue id="1174403976" type="C">International Conference on Software Engineering</venue><doi>10.1145/337180.337240</doi><keywords><keyword weight="0.43901">Permission</keyword><keyword weight="0.44488">Programming language</keyword><keyword weight="0.45384">Model checking</keyword><keyword weight="0.44416">Computer science</keyword><keyword weight="0.48241">Abstract interpretation</keyword><keyword weight="0.43451">System monitoring</keyword><keyword weight="0.42004">Real-time computing</keyword><keyword weight="0.4595">Formal specification</keyword><keyword weight="0.44635">Theoretical computer science</keyword><keyword weight="0.49441">Invariant (mathematics)</keyword><keyword weight="0.44958">Software evolution</keyword><keyword weight="0.45246">Software quality</keyword></keywords><publisher>ACM</publisher><abstract>Explicitly stated program invariants can help programmers by characterizing certain aspects of program execution and identifying program properties that must be preserved when modifying code. Unfortunately, these invariants are usually absent from code. Previous work showed how to dynamically detect invariants from program traces by looking for patterns in and relationships among variable values. A prototype implementation, Daikon, accurately recovered invariants from formally-specified programs, and the invariants it detected in other programs assisted programmers in a software evolution task. However, Daikon suffered from reporting too many invariants, many of which were not useful, and also failed to report some desired invariants. This paper presents, and gives experimental evidence of the efficacy of, four approaches for increasing the relevance of invariants reported by a dynamic invariant detector. One of them — exploiting unused polymorphism — adds desired invariants to the output. The other three — suppressing implied invariants, limiting which variables are compared to one another, and ignoring unchanged values — eliminate undesired invariants from the output and also improve runtime by reducing the work done by the invariant detector.</abstract></paper>